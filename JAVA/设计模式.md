# 23种设计模式

[狂神说](https://blog.csdn.net/qq_37021857/article/details/124283656?fromshare=blogdetail&sharetype=blogdetail&sharerId=124283656&sharerefer=PC&sharesource=qq_45760067&sharefrom=from_link)

【五分钟学设计模式.17.原型模式】 https://www.bilibili.com/video/BV1Tt4y1e7mk/?share_source=copy_web&vd_source=d15f45e46bf4f3e6570a8baae2d38973



## 1、了解设计模式

- 设计模式 是前辈们对代码开发经验的总结, 是解决特定问题的一系列套路, 他不是语法规定, 而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案
- 1995年,GoF合作出版了《设计模式:可复用面向对象软件的基础》一书,共收录了23种设计模式,从此树立了软件设计模式领域的里程碑,人称GoF设计模式

> 学习设计模式的意义

- 设计模式的本质是面向对象设计原则的实际运用, 是对类的封装性, 继承性和多态性以及类的关联关系和组合关系的充分理解
- 正确使用设计模式具有以下优点:
	- 可以提高程序员的思维能力, 编程能力和设计能力
	- 使程序设计更加标准化, 代码编制更加工程化, 使软件开发效率大大提高, 从而缩短 软件的开发周期
- 使设计的代码可重用性高, 可读性强, 可靠性高, 灵活性好, 可维护性强

## 2、GoF 23

- Gof23
	- 一种思维, 一种态度, 一种进步
- 创建型模式:（描述怎么去创建一个对象，想办法让对象的创建和使用分离）
	- 单例模式, 工厂模式, 抽象工厂模式, 建造者模式, 原型模式
- 结构型模式:（主要描述如何将咱们的类或对象按照某种布局组成一些更大的结构）
	- 适配器模式, 桥接模式, 装饰模式, 组合模式, 外观模式, 享元模式, 代理模式
- 行为型模式:（描述类或对象之间怎么相互协作共同完成单个对象无法完成的任务，主要是分配职责）
	- 模板方法模式, 命令模式, 迭代器模式, 观察者模式, 中介者模式, 备忘录模式, 解释器模式, 状态模式, 策略模式, 职责链模式, 访问者模式



## 3、OOP 七大原则

- **开闭原则**: 对扩展开放, 对修改关闭。当应用需求发生改变的时候，我们尽量不去修改原来的代码，可以在原来进行扩展（例如通过继承或实现接口）。
- **里氏替换原则**: 继承必须确保超类所拥有的性质在子类中仍然成立。我们继承一个父类的时候，尽量添加新的方法完成新的功能，不要去把父类的方法改掉，我的理解是不是不让重写，而是子类重写但是整体功能于父类相似，只是有了单独的其他实现，可以理解为功能增强
- **依赖倒置原则**: 要面向接口编程, 不要面向实现编程，降低程序的耦合性。高层的模块不应该依赖于底层的模块，两个东西都应该相对依赖他的抽象，像dao，service层一样
- **职责原则**: 控制类的粒度大小, 将对象解耦, 提高其内聚性。一个方法或一个对象干好一件事情
- **接口隔离原则**: 要为各个类建立它们需要的专用接口
- **迪米特法则**: 只与你的直接朋友交谈,不跟"陌生人"说话 不要越级交流
- **合成复用原则**: 尽量先使用组合或者聚合等关联关系实现,其次才考虑使用继承关系来实现（组合是 has a 的关系，就是作为成员变量出现；而继承是is a的关系）





## 4、创建型模式

### 单例模式

**饿汉式**：类加载时，就进行对象实例化。很饿所以一上来就给，不管调用者是否使用。

该静态成员变量必须是private的，以防止用户可以直接访问到它。如果用户想要访问该单例类的唯一实例，它只能调用该类的静态方法（getInstance）。

   静态成员变量是属于整个类的，仅在类的初次加载时初始化，在类被销毁时才会被回收。静态方法同样是属于整个类的，可以通过类名与对象名进行访问，而非静态成员是随着对象的创建而被实例化的。在调用静态方法时，可能对象还没有实例化，自然也就没有对象的非静态成员的实例化，所以无法访问非静态的成员，必须设置为静态成员变量。

```java
public class HungrySingLeton {
 
    // 创建HungrySingLeton 的一个对象，静态成员变量用来保存该类的唯一实例，该静态成员变量必须是private的，以防止用户可以直接访问到它（根据面向对象javabean的封装定义 ）
    private static final HungrySingLeton instance = new HungrySingLeton();
 
    // 私有的构造函数保证只能在类内部实例化
    private HungrySingLeton() {
    }
 
    // 获取唯一可用的对象
    public static HungrySingLeton getInstance(){
        return instance;
    }
}
```



**懒汉式**

由于饿汉式一上来就进行创建对象，不管调用者是否使用，可能会浪费空间。

因此引出懒汉式，我是想要用的时候再去创建对象，平时先放在这个地方。

https://www.cnblogs.com/xiong2ge/p/designpattern_singleton_profound.html



在学习完juc之后再看一下狂神的单例





### 工厂模式

实现了创建者和调用者的分离

- **核心本质**

	- 实例化对象不使用new, 用工厂的方法代替
	- 将选择实现类, 创建对象统一管理和控制. 从而将调用者跟我们的实现类解耦

	

- **三种模式:**
	- 简单工厂模式：用来生产统一等级结构中的任意产品(对于增加新的产品,需要复写已有代码)
	- 工厂方法模式：用来生产同一等级结构中的固定产品(支持增加任意产品)
	- 抽象工厂模式：围绕一个超级工厂创建其他工厂, 该超级工厂又称为其他工厂的工厂



#### 1、简单工厂模式

> Car

```java
package com.kuang.factory.simple;

public interface Car {
    void name();
}
```

> Tesla

```java
package com.kuang.factory.simple;

public class Tesla implements Car {
    public void name() {
        System.out.println("特斯拉");
    }
}
```

> WuLing

```java
package com.kuang.factory.simple;

public class WuLing implements Car {
    public void name() {
        System.out.println("五菱宏光");
    }
}
```

> CarFactory

```java
package com.kuang.factory.simple;

public class CarFactory {
    //静态工厂模式
    //增加一个新的产品 需要修改代码
    //方法一
    public static Car getCar(String car){
        if (car.equals("五菱宏光")){
            return new WuLing();
        }else if(car.equals("特斯拉")){
            return new Tesla();
        }else return null;
    }

    //方法二
    public static Car getWuLing(){
        return new WuLing();
    }

    public static Car getTesla(){
        return new Tesla();
    }
}
```

> Consumer

```java
package com.kuang.factory.simple;

public class Consumer {

    public static void main(String[] args) {
        //接口，所有实现类
        Car wuLing = new WuLing();
        Car tesla = new Tesla();
        wuLing.name();
        tesla.name();

        wuLing=CarFactory.getCar("五菱宏光");
        tesla=CarFactory.getCar("特斯拉");
        wuLing.name();
        tesla.name();


    }
}
```

![img](https://bobbo.oss-cn-beijing.aliyuncs.com/img_for_typora/2462830-20221127004924682-1068487260.png)

优点：实例化具体对象不需要关系具体细节，直接根据参数从工厂索要即可，初步实现了责任的分离。客户端只负责“消费”，工厂负责“生产”。生产和消费分离。

缺点：工厂类集中负责所有的创造逻辑，不能出问题，一旦出问题，整个系统瘫痪。
不符合OCP开闭原则，在进行系统拓展时，需要修改工厂类。



#### 2、工厂方法模式

> Car

```java
package com.kuang.factory.method;

public interface Car {
    void name();
}
```

> CarFactory

```java
package com.kuang.factory.method;

public interface CarFactory {
    //工厂方法模式
    Car getCar();
}
```

> Tesla

```java
package com.kuang.factory.method;

public class Tesla implements Car {
    public void name() {
        System.out.println("特斯拉");
    }
}
```

> TeslaFactory

```java
package com.kuang.factory.method;

public class TeslaFactory implements CarFactory {
    public Car getCar() {
        return new Tesla();
    }
}
```

> WuLing

```java
package com.kuang.factory.method;

public class WuLing implements Car {
    public void name() {
        System.out.println("五菱宏光");
    }
}
```

> WuLingFactory

```java
package com.kuang.factory.method;

public class WuLingFactory implements CarFactory {
    public Car getCar() {
        return new WuLing();
    }
}
```

> Consumer

```java
package com.kuang.factory.method;

import com.kuang.factory.simple.CarFactory;
import com.kuang.factory.simple.Tesla;
import com.kuang.factory.simple.WuLing;

public class Consumer {

    public static void main(String[] args) {
        //接口，所有实现类
        Car wuLing = new WuLingFactory().getCar();
        Car tesla = new TeslaFactory().getCar();
        wuLing.name();
        tesla.name();
    }
//结构复杂度: simple
//代码复杂度: simple
//编程复杂度: simple
//管理上的复杂度: simple
//舰据设计原则:工厂方法模式!
//根据实际业务:简单工厂模式!

}
```

[![img](https://bobbo.oss-cn-beijing.aliyuncs.com/img_for_typora/2462830-20221127004859070-1392721769.png)](https://img2022.cnblogs.com/blog/2462830/202211/2462830-20221127004859070-1392721769.png)

优点：

拓展性高，如果想增加一个产品，只需新增一个产品类及其对应的工厂类即可。
弱化抽象工厂的职责，将具体产品的实现交给其他工厂，职责分工明确。
		缺点：

每次再新增一个产品时，都需要增加一个具体类及其对应的工厂类，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。

​	在Spring框架中，BeanFactory使用的是工厂方法模式。

> 根据设计原则，应采用工厂方法模式
> **根据实际业务，简单工厂模式，应用更广泛**

#### 3、抽象工厂模式

【五分钟学设计模式.04.抽象工厂模式】 https://www.bilibili.com/video/BV1y54y1B7k6/?share_source=copy_web&vd_source=d15f45e46bf4f3e6570a8baae2d38973

由于工厂方法模式，他只能创造一个大类的产品，因为定义了一个抽象的产品接口，所以说创建的所有产品都属于一个大类，属于car。

那抽象工厂模式他做了一件事情 ，使得工厂不但可以生产某一大类的产品，还可以生产其他大类产品，打破了工厂与产品大类一对一的关系，一个具体的工厂类可以生产多个大类的产品

![image-20241010174448517](https://bobbo.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20241010174448517.png)



他与之前两种工厂模式最大的区别是仅仅增加了一个新的产品体系，因此和前两种工厂模式没什么不同。

但是，如果我们新增一个产品体系，必须要去修改原有的工厂逻辑（包括抽象工厂以及所有具体工厂），违反开闭原则





### 建造者模式

也叫生成器模式。

将一个复杂对象的构建与他的表示分离，使得同样的构建过程可以创建不同的表示。

在用户不知道对象的建造过程和细节的情况下，直接创建复杂对象

用户只需要给出指定复杂对象的类型和内容，建造者模式负责按顺序创建复杂对象（把内部的建造过程和细节隐藏起来）

**1. 创建一个表示 `Person` 的类**

```java
public class Person {  
    private String name;  
    private int age;  
    private String address;  
    private String phoneNumber;  
  
    // 私有构造函数，防止外部直接创建对象  
    private Person(Builder builder) {  
        this.name = builder.name;  
        this.age = builder.age;  
        this.address = builder.address;  
        this.phoneNumber = builder.phoneNumber;  
    }  
  
    // 内部静态类，用于构建 Person 对象 这意味着它可以在不创建 Person 实例的情况下被实例化，并且它完全独立于 Person 类的任何实例。
    public static class Builder {  
        private String name;  
        private int age;  
        private String address;  
        private String phoneNumber;  
  
        // 设置每个属性的方法，返回 Builder 对象本身，以便链式调用  
        public Builder setName(String name) {  
            this.name = name;  
            return this;  
        }  
  
        public Builder setAge(int age) {  
            this.age = age;  
            return this;  
        }  
  
        public Builder setAddress(String address) {  
            this.address = address;  
            return this;  
        }  
  
        public Builder setPhoneNumber(String phoneNumber) {  
            this.phoneNumber = phoneNumber;  
            return this;  
        }  
  
        // 构建最终对象的方法  
        public Person build() {  
            return new Person(this);  
        }  
    }  
  
    // Getters for demonstration purposes  
    public String getName() {  
        return name;  
    }  
  
    public int getAge() {  
        return age;  
    }  
  
    public String getAddress() {  
        return address;  
    }  
  
    public String getPhoneNumber() {  
        return phoneNumber;  
    }  
  
    @Override  
    public String toString() {  
        return "Person{" +  
                "name='" + name + '\'' +  
                ", age=" + age +  
                ", address='" + address + '\'' +  
                ", phoneNumber='" + phoneNumber + '\'' +  
                '}';  
    }  
}
```

**2. 使用生成器模式创建 `Person` 对象**

```java
public class Main {  
    public static void main(String[] args) {  
        // 创建一个 Person 对象  
        Person person = new Person.Builder()  
                .setName("John Doe")  
                .setAge(30)  
                .setAddress("123 Main St")  
                .setPhoneNumber("123-456-7890")  
                .build();  
  
        // 输出 Person 对象的信息  
        System.out.println(person);  
    }  
}
//解释

1. Person 类

	：

	- 有一个私有构造函数，它接受一个 `Builder` 对象作为参数。
	- 有一个内部静态类 `Builder`，包含所有 `Person` 对象的属性，以及用于设置这些属性的方法。
	- 每个设置属性的方法返回 `Builder` 对象本身，以便支持链式调用。
	- `build` 方法用于创建并返回最终的 `Person` 对象。

2. Main 类

	：

	- 演示了如何使用 `Builder` 类来创建 `Person` 对象。
	- 通过链式调用设置 `Person` 对象的属性，然后调用 `build` 方法来构建最终的 `Person` 对象。
```

> 在lombok中提供了@builder注解，可以为该类实现builder模式
>
> 在手动实现 Builder 模式时，往往需要：
>
> - 编写一个静态内部类 `Builder`。
> - 创建一系列的 setter 方法。
> - 最后提供 `build()` 方法来返回构建好的对象。 这些代码虽然实现了灵活的对象创建，但冗长、重复。而 `@Builder` 注解通过自动生成这些重复代码，帮助开发者减少样板代码的编写，提高开发效率。



### 原型模式



它允许通过复制现有的对象来创建新对象，而不是通过实例化类来创建。这种模式特别适用于对象创建成本较高的场景，通过原型模式可以避免重复的复杂对象构建过程。

把原来的原型直接复制一份副本，并且可以针对副本进行修改，但原来的对象不会产生任何变化

**原型模式的实现步骤：**

1. **实现原型接口**：在 Java 中，类需要实现 `Cloneable` 接口。

2. **重写 `clone()` 方法**：在类中重写 object的`clone()` 方法

	> 1. **实现 `Cloneable` 接口**：
	> 	- `Cloneable` 是一个标记接口，表示该类的实例可以被克隆。实现这个接口表明该类的设计者支持对象的复制。
	> 	- 如果类没有实现 `Cloneable` 接口，调用 `clone()` 方法会抛出 `CloneNotSupportedException` 异常。这种机制是为了防止不希望被复制的对象意外被克隆。
	> 2. **重写 `clone()` 方法**：
	> 	- 默认情况下，`Object` 类的 `clone()` 方法是浅拷贝（shallow copy），即仅复制对象的引用而不是对象的实际内容。重写 `clone()` 方法可以实现深拷贝（deep copy），以便复制对象的所有字段（包括引用类型的字段）。
	> 	- 通过重写 `clone()` 方法，开发者可以自定义克隆行为，例如创建一个新的实例并复制其状态。
	>
	> 总结来说，实现 `Cloneable` 接口和重写 `clone()` 方法是为了确保对象能够被安全且有效地克隆，同时提供对克隆过程的自定义控制。

> **方法体内默认调用的是super.clone(),是浅拷贝;**
>
> **但是浅拷贝场景下，原型对象v1和克隆对象v2对于引用类型属性来说，是指向的同一个引用数据对象**。只是把原型对象v1的值包括引用也拷贝过来了，所以指向的是同一个date 。![image-20241011152954647](https://bobbo.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20241011152954647.png)
>
> 而深拷贝，就是克隆对象有自己独立的引用成员属性对象，但这需要这个引用数据类型成员类需要实现接口 重写方法（类似于套娃一样，如果它里面的属性还需要深拷贝 还得实现接口 重写方法）
>
> ![image-20241011153435645](https://bobbo.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20241011153435645.png)

> 深拷贝实现方式
>
> 1. 序列化和反序列化，涉及到操作io了，效率肯定会降低一些
> 2. 克隆的方法

3. **使用 `clone()` 创建对象**：通过调用 `clone()` 方法来创建对象，而不是 `new` 来生成新对象。



**浅拷贝示例**

```java
**
 * 浅克隆：将对象的值完全拷贝一份，
 * 		如果属性为引用类型变量，则拷贝属性指向的内存地址
 * 实现Cloneable接口
 * 重写 clone 方法（不做改造）
 */
public class Student implements Cloneable{
    public int id;
    public Integer age;
    public String name;
    public Date createTime;

    public Student(int id, Integer age, String name,Date createTime) {
        this.id = id;
        this.age = age;
        this.name = name;
        this.createTime = createTime;
    }

    @Override
    public String toString() {
        return "Student{" + "id=" + id + ", age=" + age + ", name='" + name + '\'' + ", createTime=" + createTime + '}';
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }

    public static void main(String[] args) throws Exception {
        Student stu_1 = new Student(1,18,"小红",new Date());
        Student stu_2 = (Student) stu_1.clone();
        System.out.println(stu_1);
        System.out.println(stu_2);

        System.out.println("-------修改stu_2的值------");
        stu_2.id = 2;       //不影响原对象
        stu_2.age = 20;    //不影响原对象
        stu_2.name = "小兰";//不影响原对象
        // ------- 影响原对象 -------
        stu_2.createTime.setTime(22123156); //修改了stu_2对象 ，但是stu_1对象也被修改
        System.out.println(stu_1);
        System.out.println(stu_2);
    }
}
输出结果为：
Student{id=1, age=18, name='小红', createTime=Sun Apr 24 12:39:28 CST 2022}
Student{id=1, age=18, name='小红', createTime=Sun Apr 24 12:39:28 CST 2022}
-------修改stu_2的值------
Student{id=1, age=18, name='小红', createTime=Thu Jan 01 14:08:43 CST 1970}
Student{id=2, age=20, name='小兰', createTime=Thu Jan 01 14:08:43 CST 1970}

```

```java
/**
* 实现深克隆的方式：
*  1.序列化与反序列化，但性能较低
*  2.改造clone方法
*/
@Override
protected Object clone() throws CloneNotSupportedException {
    Student stu = (Student) super.clone();
    //将引用类型的变量，也克隆一份
    stu.createTime = (Date) this.createTime.clone();
    return stu;
}
输出结果为：
Student{id=1, age=18, name='小红', createTime=Sun Apr 24 12:39:28 CST 2022}
Student{id=1, age=18, name='小红', createTime=Sun Apr 24 12:39:28 CST 2022}
-------修改stu_2的值------
Student{id=1, age=18, name='小红', createTime=Sun Apr 24 12:39:28 CST 2022}
Student{id=2, age=20, name='小兰', createTime=Thu Jan 01 14:08:43 CST 1970}
```





## 5.结构型模式

### 适配器模式

将一个类的接口转换成客户端所期待的另一种接口，从而使得原本因接口不匹配而无法在一起工作的类能够一起工作。

![image-20241012112354959](https://bobbo.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20241012112354959.png)

第一个类是Adapter，他就是适配器；Adaptee，他就是被适配的类，当我们的客户想要去访问原有的类的功能的时候，通过适配器可以无缝使用。

适配的方式有两种：第一种叫做关联使用，把被适配的对象放在适配器内，通过访问适配器的方法间接调用被适配的方法；第二种方法叫做继承，成为子类，通过访问子类间接访问被适配的类。

> 和装饰器模式的区别
>
> 适配器是原有接口挺好用，但是客户端不兼容，适配器提供一个适配的作用

```java
// 定义目标接口 
public interface Target {
  void request(); }

// 定义被适配的类，已有的类
public class Adaptee {
    public void specificRequest() {
        System.out.println("Called specificRequest from Adaptee");
    }
}

//适配的方式一：继承
// 适配器通过继承被适配的类实现目标接口
public class ClassAdapter extends Adaptee implements Target {

    @Override
    public void request() {
        // 将目标接口的调用转换为被适配类的调用
        specificRequest();
    }
}


//适配的方式二：关联
// 适配器通过组合被适配类实现目标接口
public class ObjectAdapter implements Target {
    private Adaptee adaptee;  // 组合

    public ObjectAdapter(Adaptee adaptee) {
        this.adaptee = adaptee;
    }

    @Override
    public void request() {
        // 将目标接口的调用转换为被适配类的调用
        adaptee.specificRequest();
    }
}
```

#### 适配器模式的实际例子

1. **Java I/O Streams** 在 Java 中，`InputStream` 和 `Reader`，`OutputStream` 和 `Writer` 之间是互不兼容的，但是通过 `InputStreamReader` 和 `OutputStreamWriter` 适配器类，可以将字节流转换为字符流，方便地进行数据读写操作。
2. **Spring 的 HandlerAdapter** 在 Spring MVC 框架中，`HandlerAdapter` 用于将不同的 Controller 适配为统一的处理机制。不同类型的控制器（例如普通的控制器类和 REST 控制器）可以通过不同的适配器处理，最终达到统一的请求处理逻辑。
3. **数据库驱动** 不同数据库的访问接口不尽相同，但 Java 的 JDBC 驱动通过适配器模式，提供了一个统一的接口。无论是 MySQL、PostgreSQL 还是 Oracle 数据库，JDBC 都可以通过适配器将其适配成标准的 `Connection`、`Statement` 等接口，方便客户端统一操作不同的数据库。





### 桥接模式

桥接模式是一种解耦设计，它将抽象部分与实现部分分离，使得它们可以独立变化。通过这种方式，可以有效地减少代码的复杂性，避免类的**组合爆炸**问题，并使系统具有更好的扩展性。

典型的桥接模式结构：

- **Abstraction（抽象类）**：定义了具体的业务接口，并通过组合 `Implementor` 来进行具体操作。
- **RefinedAbstraction（扩充抽象类）**：继承自 `Abstraction`，提供具体业务逻辑的实现。
- **Implementor（实现接口）**：定义了实现部分的接口，抽象部分通过调用它实现具体功能。
- **ConcreteImplementor（具体实现类）**：实现了 `Implementor` 接口，提供具体的实现逻辑。

![image-20241012141918257](https://bobbo.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20241012141918257.png)



上图为多重继承模式，类的个数比较多，扩展比较麻烦；
		下图为抽象出两个纬度，减少类的构建：

![image-20241012142000906](https://bobbo.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20241012142000906.png)

```java
//1.品牌纬度 --------------- 接口：电脑品牌 --------------- 
public interface Brand {
    void brandName();
}
//联想品牌
public class Lenovo implements Brand {
    @Override
    public void brandName() {
        System.out.print("联想品牌");
    }
}
//苹果品牌
public class Apple implements Brand {
    @Override
    public void brandName() {
        System.out.print("苹果品牌");
    }
}
//2.种类纬度 --------------- 抽象类：电脑种类 --------------- 
public abstract class Computer {
    //通过组合的方式，给电脑增加上品牌属性
    protected Brand brand;
    //构造器中，引入品牌（出厂自带品牌）
    public Computer(Brand brand) {
        this.brand = brand;
    }
    //输出电脑信息：品牌 + 种类
    abstract void computerInfo();
}
//笔记本
public class NoteBook extends Computer {
    public NoteBook(Brand brand) { super(brand); }
    @Override
    void computerInfo() {
        brand.brandName();
        System.out.println("笔记本");
    }
}
//平板
public class Flat extends Computer {
    public Flat(Brand brand) { super(brand); }
    @Override
    void computerInfo() {
        brand.brandName();
        System.out.println("平板");
    }
}
//3. ----------- 测试 ------------
public static void main(String[] args) {
    //苹果笔记本
    Computer computer = new NoteBook(new Apple());
    computer.computerInfo();
    //联想平板
    Computer computer2 = new Flat(new Lenovo());
    computer2.computerInfo();
}
输出结果：
苹果品牌笔记本
联想品牌平板
```

![image-20241012142219236](https://bobbo.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20241012142219236.png)

**优点：**

**降低类的数量**：

- 通过将抽象部分和实现部分分离，桥接模式避免了因每种组合都生成子类而导致的类数量爆炸问题。只需要在两个独立的层次上进行扩展，而不需要为每种组合创建新的类。

**提高系统的灵活性**：

- 抽象部分和实现部分可以独立变化，允许你在不修改现有代码的情况下添加新的实现或抽象。这种灵活性使得系统更易于扩展和维护。

**更好的可扩展性**：

- 由于可以在运行时动态地选择实现，桥接模式使得系统在设计时更加可扩展。例如，你可以在运行时选择不同的实现方式，满足不同的需求。

**缺点**

1. **增加了系统的复杂性**：
	- 桥接模式的引入可能导致系统的复杂性增加，因为需要创建抽象类和实现类，增加了理解和使用的难度。设计者需要花费额外的时间来理解这种模式的结构。
2. **可能导致过度设计**：
	- 在某些情况下，如果系统的需求比较简单，使用桥接模式可能导致过度设计。对于简单的系统，引入桥接模式可能显得不必要，增加了不必要的复杂性。
3. **需要额外的维护**：
	- 桥接模式引入的层次结构可能需要额外的维护成本，特别是在系统规模较大时。不同的实现和抽象层之间的关系可能会使得调试和维护变得更加复杂。
4. **性能开销**：
	- 由于在运行时需要通过桥接类进行方法调用，可能会引入一定的性能开销。





### 装饰器模式

> 实现给一个类或者对象增加新的功能，有两种方式：
>
> ​	一是继承机制，继承一个现有的类，在子类进行扩展功能，这种方式是静态的，一定要实现一个子类，对类层级进行扩展
>
> ​	二是关联机制，把一个类的对象嵌入到另一个类的对象中，作为成员变量，来扩展功能，这种方式就是装饰器模式，他是动态的，我们拿到一个对象就可以对其扩展，不需要改变原有类的逻辑

动态的给一个对象添加一些额外的功能，就增加功能来说，装饰器模式比生成子类更加灵活。

```java
//定义机器人接口
interface Rebot{
  void doSomething();
}

//定义第一代机器人
class FirstRebot implements Rebot{
  
  public void doSomething(){
    sout("123");
      
  }
}

//装饰器
class RebotDecorator implements Rebot{
  //关联使用
  private Rebot rebot；
  public RebotDecorator(Rebot rebot){
    this.rebot = rebot;
  }
  // 不添加新的功能，直接调用
  public void doSomething(){
    rebot.doSomething();
  }
  
   public void doMorething(){
    rebot.doSomething();
     //添加新的功能
     sout("1233213")
  }
  
  
  
}
```



注意 Java的io流大量使用了装饰器模式

> Java 的 I/O 流库广泛使用了**装饰器模式**来提供灵活和可扩展的输入输出操作。通过装饰器模式，Java 能够让开发者根据需求动态地组合不同的功能，而不是通过大量的子类继承来实现功能的扩展。
>
> ### Java I/O 流中的装饰器模式：
>
> 在 Java I/O 流中，**`InputStream`** 和 **`OutputStream`** 是基本的抽象类，代表字节流的输入和输出。像 **`FileInputStream`** 和 **`FileOutputStream`** 这样的类是具体组件，用于处理文件的字节输入和输出。而装饰器类，比如 **`BufferedInputStream`**、**`DataInputStream`**、**`BufferedOutputStream`**、**`DataOutputStream`** 等，都是通过装饰器模式扩展基本的 I/O 功能。
>
> ### 主要参与类：
>
> - **组件接口**（Component）：`InputStream` 和 `OutputStream` 是字节流输入输出的基本接口，定义了流的基础操作。
> - **具体组件**（ConcreteComponent）：`FileInputStream`、`FileOutputStream` 等类实现了基础的流功能，提供了从文件或其他源读取或写入数据的功能。
> - **装饰器基类**（Decorator）：`FilterInputStream` 和 `FilterOutputStream` 是装饰器基类，持有一个 `InputStream` 或 `OutputStream` 对象的引用，并在其基础上进行扩展。
> - **具体装饰器**（ConcreteDecorator）：`BufferedInputStream`、`DataInputStream`、`BufferedOutputStream`、`DataOutputStream` 等，具体提供了诸如缓冲、读取基本数据类型等附加功能。
>
> ### 常见例子：
>
> 假设我们从文件读取数据，并希望添加缓冲区以提高读取效率，以下是装饰器模式的典型使用方式：
>
> ```
> java复制代码import java.io.*;
> 
> public class DecoratorIOExample {
>     public static void main(String[] args) {
>         try {
>             // 创建文件输入流
>             FileInputStream fileInputStream = new FileInputStream("example.txt");
>             
>             // 用 BufferedInputStream 装饰 FileInputStream，增加缓冲功能
>             BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream);
>             
>             // 用 DataInputStream 装饰 BufferedInputStream，可以读取基本数据类型
>             DataInputStream dataInputStream = new DataInputStream(bufferedInputStream);
>             
>             // 读取文件内容
>             String line = dataInputStream.readLine(); // 读取一行文本
>             System.out.println("Read from file: " + line);
>             
>             // 关闭流
>             dataInputStream.close();
>         } catch (IOException e) {
>             e.printStackTrace();
>         }
>     }
> }
> ```
>
> ### 具体类解释：
>
> 1. **`FileInputStream`**：负责从文件中逐字节读取数据，是具体组件。
> 2. **`BufferedInputStream`**：装饰器类，为 `FileInputStream` 提供缓冲机制，减少对底层系统的直接访问，提高读取效率。
> 3. **`DataInputStream`**：另一个装饰器，提供了读取基本数据类型（如 `int`、`double` 等）的能力，而不只是读取字节。







### 组合模式

用于将对象组合成树形结构，以表示“部分-整体”的层次结构。它允许客户端对单个对象和组合对象（容器）使用统一的方式进行处理，从而简化了复杂的树形结构中的操作。

  关键点：

- **树形结构**：组合模式通过递归组合对象，形成一棵树。叶子节点表示简单对象，容器节点表示包含其他对象的复杂对象（可以是叶子节点或其他容器节点）。
- **统一接口**：组合模式提供一个统一的接口，让客户端可以一致地对待单个对象和组合对象，而不需要区分它们的类型。



**示例**：

通过组合模式（Composite Pattern）来计算全国各省市的人口数量，是一个非常合适的应用场景。我们可以将国家、省、城市、区县等视为层级结构的节点，每个节点都可以作为**组合对象**（如省、国家）或**叶子节点**（如城市、区县）。组合节点会包含其他子节点，叶子节点则只表示具体的人口数量。

设计思路：

1. **组件接口（Component）**：定义所有节点的共同操作，如获取人口的方法。
2. **叶子节点（Leaf）**：表示具体的城市或区县，拥有实际人口数据。
3. **组合节点（Composite）**：表示省或国家，可以包含多个城市或其他组合节点（如省、国家），它将递归地获取所有子节点的人口数量总和。

代码实现：

```java
import java.util.ArrayList;
import java.util.List;

// 定义统一的接口
interface PopulationComponent {
    int getPopulation();  // 获取人口
    void showDetails();   // 展示详情
}

// 叶子节点：具体城市或区县
class City implements PopulationComponent {
    private String name;
    private int population;

    public City(String name, int population) {
        this.name = name;
        this.population = population;
    }

    @Override
    public int getPopulation() {
        return population;  // 返回城市或区县的具体人口
    }

    @Override
    public void showDetails() {
        System.out.println(name + " population: " + population);
    }
}

// 组合节点：省或国家，可以包含多个城市或省
class Province implements PopulationComponent {
    private String name;
  //接口多态
    private List<PopulationComponent> cities = new ArrayList<>();

    public Province(String name) {
        this.name = name;
    }

    // 添加子节点
    public void add(PopulationComponent city) {
        cities.add(city);
    }

    // 移除子节点
    public void remove(PopulationComponent city) {
        cities.remove(city);
    }

    // 获取该省的总人口（包含所有子节点）
    @Override
    public int getPopulation() {
        int totalPopulation = 0;
        for (PopulationComponent city : cities) {
            totalPopulation += city.getPopulation();  // 累加所有子节点的人口
        }
        return totalPopulation;
    }

    @Override
    public void showDetails() {
        System.out.println(name + " population: " + getPopulation());
        for (PopulationComponent city : cities) {
            city.showDetails();  // 递归显示子节点的详情
        }
    }
}

// 组合节点：国家，可以包含多个省
class Country implements PopulationComponent {
    private String name;
    private List<PopulationComponent> provinces = new ArrayList<>();

    public Country(String name) {
        this.name = name;
    }

    // 添加子节点
    public void add(PopulationComponent province) {
        provinces.add(province);
    }

    // 移除子节点
    public void remove(PopulationComponent province) {
        provinces.remove(province);
    }

    // 获取全国总人口
    @Override
    public int getPopulation() {
        int totalPopulation = 0;
        for (PopulationComponent province : provinces) {
            totalPopulation += province.getPopulation();  // 累加所有省的人口
        }
        return totalPopulation;
    }

    @Override
    public void showDetails() {
        System.out.println(name + " total population: " + getPopulation());
        for (PopulationComponent province : provinces) {
            province.showDetails();  // 递归显示省的详情
        }
    }
}

// 测试代码
public class CompositePatternExample {
    public static void main(String[] args) {
        // 创建城市
        City city1 = new City("Beijing", 2171); // 单位：万
        City city2 = new City("Shanghai", 2424);
        City city3 = new City("Guangzhou", 1867);
        City city4 = new City("Shenzhen", 1253);

        // 创建省份，并添加城市
        Province province1 = new Province("Beijing Municipality");
        province1.add(city1);

        Province province2 = new Province("Shanghai Municipality");
        province2.add(city2);

        Province province3 = new Province("Guangdong Province");
        province3.add(city3);
        province3.add(city4);

        // 创建国家，并添加省份
        Country china = new Country("China");
        china.add(province1);
        china.add(province2);
        china.add(province3);

        // 显示全国的人口信息
        china.showDetails();  // 输出国家、省、城市的总人口信息
    }
}
```

**输出结果：**

```
China total population: 7715
Beijing Municipality population: 2171
Beijing population: 2171
Shanghai Municipality population: 2424
Shanghai population: 2424
Guangdong Province population: 3120
Guangzhou population: 1867
Shenzhen population: 1253
```

**解释：**

1. **组件接口**：`PopulationComponent` 定义了两个核心方法 `getPopulation()`（获取人口数量）和 `showDetails()`（显示详情）。无论是城市、省份还是国家，都需要实现这些方法。
2. **叶子节点（City）**：表示具体的城市，包含城市的人口数据，`getPopulation()` 返回城市的人口。
3. **组合节点（Province、Country）**：分别表示省和国家，内部包含一个 `List` 来存储子节点（城市或省），`getPopulation()` 会遍历所有子节点，递归累加子节点的人口数量。
4. **递归调用**：组合模式中的 `getPopulation()` 和 `showDetails()` 方法可以递归地遍历树结构，计算并显示各个层级的总人口信息。

**组合模式的优点：**

1. **层次结构清晰**：组合模式可以方便地构建复杂的层次结构，如省、市、国家等层级。
2. **操作简化**：客户端可以通过统一接口操作不同层次的对象，而不需要分别处理叶子节点和组合节点。
3. **扩展性强**：可以轻松地添加新的省份、城市，而不需要修改现有代码，符合开放/封闭原则。

**总结：**

通过组合模式，我们可以轻松实现对全国、省、市等层级的递归管理和数据统计。组合模式使得处理复杂的树形结构变得简单高效，客户端无需关心具体的层级结构，只需统一地操作接口。



### 外观模式

把各个子系统的方法攒成外观类的一个方法 直接调用

它为复杂的子系统提供了一个简化的接口，使得客户端可以更容易地与子系统进行交互。通过外观模式，客户端无需深入了解子系统的细节，只需通过一个统一的接口与其交互，从而降低了系统的复杂性。

通过引入一个外观类（Facade），为复杂的子系统提供一个简化的接口。这个外观类将子系统的各个部分隐藏起来，客户端不需要直接调用子系统的各个模块，只需与外观类进行交互。

但是**不完全符合开闭原则**：当外观类需要进行修改时，可能会影响到所有依赖它的客户端。

```java
// 子系统A
class SubsystemA {
    public void operationA() {
        System.out.println("Subsystem A operation");
    }
}

// 子系统B
class SubsystemB {
    public void operationB() {
        System.out.println("Subsystem B operation");
    }
}

// 外观类
class Facade {
    private SubsystemA subsystemA;
    private SubsystemB subsystemB;

    public Facade() {
        subsystemA = new SubsystemA();
        subsystemB = new SubsystemB();
    }

    public void performOperation() {
        subsystemA.operationA();
        subsystemB.operationB();
    }
}

// 客户端
public class Client {
    public static void main(String[] args) {
        Facade facade = new Facade();
        facade.performOperation();  // 通过外观类简化对子系统的调用
    }
}
```





### 享元模式

享元模式的关键思想是**避免重复创建相似的对象**，通过共享同一个对象来减少资源消耗，尤其在需要大量相似对象的场景下。

运用共享技术有效的支持大量细粒度的对象。

**核心思想**

享元模式将对象分为**内部状态（Intrinsic State）\*和\**外部状态（Extrinsic State）**：

- **内部状态**：对象可以共享的部分，通常是不变的，在享元对象内部存储，不依赖于外部环境。
- **外部状态**：对象的可变部分，依赖于外部环境，不共享的、每个实例独有的状态。

通过分离这两种状态，享元模式使得大量对象可以共享内部状态，从而避免了重复创建相同的对象。



享元模式最典型的运用就是池技术，字符串常量池，数据库连接池，线程池

**享元模式的结构：**

享元模式的参与者包括以下角色：

1. **Flyweight（抽象享元角色）**：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。
2. 可共享的具体享元（Concrete Flyweight）角色 ：它实现了抽象享元类，称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。
3. 非共享的具体享元（Unshared Flyweight)角色 ：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。
4. 享元工厂（Flyweight Factory）角色 ：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。



**示例**

```java
/**
 * 抽象享元类
 **/
public abstract class Flyweight {

    public abstract void operation(String extrinsicState);

}




//具体享元类,具体享元类中要将内部状态和外部状态分开处理,内部状态作为具体享元类的成员变量,而外部状态通过注入的方式添加到具体享元类中.
/**
 * 可共享-具体享元类
 **/
public class ConcreteFlyweight extends Flyweight {

    //内部状态 intrinsicState作为成员变量,同一个享元对象的内部状态是一致的
    private String intrinsicState;

    public ConcreteFlyweight(String intrinsicState) {
        this.intrinsicState = intrinsicState;
    }

    /**
     * 外部状态在使用时由外部设置,不保存在享元对象中,即使是同一个对象
     * @param extrinsicState  外部状态,每次调用可以传入不同的外部状态
     */
    @Override
    public void operation(String extrinsicState) {
        //实现业务方法
        System.out.println("=== 享元对象内部状态" + intrinsicState +",外部状态:" + extrinsicState);
    }
}





//非共享享元类,不复用享元工厂内部状态,但是是抽象享元类的子类或实现类
/**
 * 非共享具体享元类
 * @author spikeCong
 * @date 2022/10/10
 **/
public class UnsharedConcreteFlyweight extends Flyweight {

    private String intrinsicState;

    public UnsharedConcreteFlyweight(String intrinsicState) {
        this.intrinsicState = intrinsicState;
    }


    @Override
    public void operation(String extrinsicState) {
        System.out.println("=== 使用不共享对象,内部状态: " + intrinsicState +",外部状态: " + extrinsicState);
    }
}



///**
 * 享元工厂类
 *      作用: 作为存储享元对象的享元池.用户获取享元对象时先从享元池获取,有则返回,没有创建新的
 *      享元对象返回给用户,并在享元池中保存新增的对象.
 **/
public class FlyweightFactory {

    //定义一个HashMap用于存储享元对象,实现享元池
    private Map<String,Flyweight> pool = new HashMap();

    public FlyweightFactory() {
        //添加对应的内部状态
        pool.put("A",new ConcreteFlyweight("A"));
        pool.put("B",new ConcreteFlyweight("B"));
        pool.put("C",new ConcreteFlyweight("C"));
    }

    //根据内部状态来进行查找
    public Flyweight getFlyweight(String key){
        //对象存在,从享元池直接返回
        if(pool.containsKey(key)){
            System.out.println("===享元池中存在,直接复用,key:" + key);
            return pool.get(key);

        }else{
            //如果对象不存在,先创建一个新的对象添加到享元池中,然后返回
            System.out.println("===享元池中不存在,创建并复用,key:" + key);
            Flyweight fw = new ConcreteFlyweight(key);
            pool.put(key,fw);
            return fw;
        }
    }
} 
```





**享元模式应用实例**
五子棋中有大量的黑子和白子,它们的形状大小都是一样的,只是出现的位置不同,所以一个棋子作为一个独立的对象存储在内存中,会导致大量的内存的浪费,我们使用享元模式来进行优化.



类图如下

![image-20241015161743975](https://bobbo.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20241015161743975.png)

代码如下

```java
/**
 * 抽象享元类: 五子棋类
 **/
public abstract class GobangFlyweight {

    public abstract String getColor();

    public void display(){
        System.out.println("棋子颜色: " + this.getColor());
    }
}

/**
 * 共享享元类-白色棋子
 **/
public class WhiteGobang extends GobangFlyweight{

    @Override
    public String getColor() {
        return "白色";
    }
}

/**
 * 共享享元类-黑色棋子
 **/
public class BlackGobang extends GobangFlyweight {

    @Override
    public String getColor() {
        return "黑色";
    }
}

/**
 * 享元工厂类-生产围棋棋子,使用单例模式进行设计
 **/
public class GobangFactory {

    private static GobangFactory factory = new GobangFactory();

    private static Map<String,GobangFlyweight> pool;

    //设置共享对象的内部状态,在享元对象中传递
    private GobangFactory() {
        pool = new HashMap<String,GobangFlyweight>();
        GobangFlyweight black = new BlackGobang(); //黑子
        GobangFlyweight white = new WhiteGobang(); //白子
        pool.put("b",black);
        pool.put("w",white);
    }

    //返回享元工厂类唯一实例
    public static final GobangFactory getInstance(){
        return SingletonHolder.INSTANCE;
    }

    //静态内部类-单例
    private static class SingletonHolder{
        private static final GobangFactory INSTANCE = new GobangFactory();
    }

    //通过key获取集合中的享元对象
    public GobangFlyweight getGobang(String key){
        return pool.get(key);
    }
}

public class Client {

    public static void main(String[] args) {

        //获取享元工厂对象
        GobangFactory instance = GobangFactory.getInstance();

        //获取3颗黑子
        GobangFlyweight b1 = instance.getGobang("b");
        GobangFlyweight b2 = instance.getGobang("b");
        GobangFlyweight b3 = instance.getGobang("b");
        System.out.println("判断两颗黑子是否相同: " + (b1 == b2));

        //获取2颗白子
        GobangFlyweight w1 = instance.getGobang("w");
        GobangFlyweight w2 = instance.getGobang("w");
        System.out.println("判断两颗白子是否相同: " + (w1 == w2));

        //显示棋子
        b1.display();
        b2.display();
        b3.display();
        w1.display();
        w2.display();
    }
}

```

三颗黑子(两颗白子)对象比较之后内存地址都是一样的.说明它们是同一个对象.在实现享元模式时使用了单例模式和简单工厂模式,保证了享元工厂对象的唯一性,并提供工厂方法向客户端返回享元对象.







### 代理模式

代理(Proxy)是一种设计模式,提供了对目标对象另外的访问方式;即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能.
这里使用到编程中的一个思想:不要随意去修改别人已经写好的代码或者方法,如果需改修改,可以通过代理的方式来扩展该方法

举个例子来说明代理的作用:假设我们想邀请一位明星,那么并不是直接连接明星,而是联系明星的经纪人,来达到同样的目的.明星就是一个目标对象,他只要负责活动中的节目,而其他琐碎的事情就交给他的代理人(经纪人)来解决.这就是代理思想在现实中的一个例子

用图表示如下:

![img](https://images2015.cnblogs.com/blog/790334/201701/790334-20170116124522880-1137330008.png)

代理模式的关键点是:代理对象与目标对象.代理对象是对目标对象的扩展,并会调用目标对象

#### 1.1.静态代理

静态代理在使用时,需要定义接口或者父类,被代理对象与代理对象一起实现相同的接口或者是继承相同父类.

下面举个案例来解释:
模拟保存动作,定义一个保存动作的接口:IUserDao.java,然后目标对象实现这个接口的方法UserDao.java,此时如果使用静态代理方式,就需要在代理对象(UserDaoProxy.java)中也实现IUserDao接口.调用的时候通过调用代理对象的方法来调用目标对象.
需要注意的是,代理对象与目标对象要实现相同的接口,然后通过调用相同的方法来调用目标对象的方法

代码示例:
接口:IUserDao.java

```java
/**
 * 接口
 */
public interface IUserDao {

    void save();
}
```

目标对象:UserDao.java

```java
/**
 * 接口实现
 * 目标对象
 */
public class UserDao implements IUserDao {
    public void save() {
        System.out.println("----已经保存数据!----");
    }
}
```

代理对象:UserDaoProxy.java

```java
/**
 * 代理对象,静态代理
 */
public class UserDaoProxy implements IUserDao{
    //接收保存目标对象
    private IUserDao target;
    public UserDaoProxy(IUserDao target){
        this.target=target;
    }

    public void save() {
        System.out.println("开始事务...");
        target.save();//执行目标对象的方法
        System.out.println("提交事务...");
    }
}
```

测试类:App.java

```java
/**
 * 测试类
 */
public class App {
    public static void main(String[] args) {
        //目标对象
        UserDao target = new UserDao();

        //代理对象,把目标对象传给代理对象,建立代理关系
        UserDaoProxy proxy = new UserDaoProxy(target);

        proxy.save();//执行的是代理的方法
    }
}
```

**静态代理总结:**
1.可以做到在不修改目标对象的功能前提下,对目标功能扩展.
2.缺点:

- 因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护.

如何解决静态代理中的缺点呢?答案是可以使用动态代理方式

#### 1.2.动态代理

**动态代理有以下特点:**
1.代理对象,不需要实现接口
2.代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)
3.动态代理也叫做:JDK代理,接口代理

**JDK中生成代理对象的API**
代理类所在包:java.lang.reflect.Proxy
JDK实现代理只需要使用newProxyInstance方法,但是该方法需要接收三个参数,完整的写法是:

```java
static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces,InvocationHandler h )
```

注意该方法是在Proxy类中是静态方法,且接收的三个参数依次为:

- `ClassLoader loader,`:指定当前目标对象使用类加载器,获取加载器的方法是固定的
- `Class<?>[] interfaces,`:目标对象实现的接口的类型,使用泛型方式确认类型
- `InvocationHandler h`:事件处理,执行目标对象的方法时,会触发事件处理器的方法,会把当前执行目标对象的方法作为参数传入

代码示例:
接口类IUserDao.java以及接口实现类,目标对象UserDao是一样的,没有做修改.在这个基础上,增加一个代理工厂类(ProxyFactory.java),将代理类写在这个地方,然后在测试类(需要使用到代理的代码)中先建立目标对象和代理对象的联系,然后代用代理对象的中同名方法

代理工厂类:ProxyFactory.java

```java
/**
 * 创建动态代理对象
 * 动态代理不需要实现接口,但是需要指定接口类型
 */
public class ProxyFactory{

    //维护一个目标对象
    private Object target;
    public ProxyFactory(Object target){
        this.target=target;
    }

   //给目标对象生成代理对象
    public Object getProxyInstance(){
        return Proxy.newProxyInstance(
                target.getClass().getClassLoader(),
                target.getClass().getInterfaces(),
                new InvocationHandler() {
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        System.out.println("开始事务2");
                        //执行目标对象方法
                        Object returnValue = method.invoke(target, args);
                        System.out.println("提交事务2");
                        return returnValue;
                    }
                }
        );
    }

}
```

测试类:App.java

```java
/**
 * 测试类
 */
public class App {
    public static void main(String[] args) {
        // 目标对象
        IUserDao target = new UserDao();
        // 【原始的类型 class cn.itcast.b_dynamic.UserDao】
        System.out.println(target.getClass());

        // 给目标对象，创建代理对象
        IUserDao proxy = (IUserDao) new ProxyFactory(target).getProxyInstance();
        // class $Proxy0   内存中动态生成的代理对象
        System.out.println(proxy.getClass());

        // 执行方法   【代理对象】
        proxy.save();
    }
}
```

**总结:**
代理对象不需要实现接口,但是目标对象一定要实现接口,否则不能用动态代理

#### 1.3.Cglib代理

上面的静态代理和动态代理模式都是要求目标对象是实现一个接口的目标对象,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候就可以使用以目标对象子类的方式类实现代理,这种方法就叫做:Cglib代理

Cglib代理,也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展.

- JDK的动态代理有一个限制,就是使用动态代理的对象必须实现一个或多个接口,如果想代理没有实现接口的类,就可以使用Cglib实现.
- Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口.它广泛的被许多AOP的框架使用,例如Spring AOP和synaop,为他们提供方法的interception(拦截)
- Cglib包的底层是通过使用一个小而块的字节码处理框架ASM来转换字节码并生成新的类.不鼓励直接使用ASM,因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉.

Cglib子类代理实现方法:
1.需要引入cglib的jar文件,但是Spring的核心包中已经包括了Cglib功能,所以直接引入`pring-core-3.2.5.jar`即可.
2.引入功能包后,就可以在内存中动态构建子类
3.代理的类不能为final,否则报错
4.目标对象的方法如果为final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法.

代码示例:
目标对象类:UserDao.java

```java
/**
 * 目标对象,没有实现任何接口
 */
public class UserDao {

    public void save() {
        System.out.println("----已经保存数据!----");
    }
}
```

Cglib代理工厂:ProxyFactory.java

```java
/**
 * Cglib子类代理工厂
 * 对UserDao在内存中动态构建一个子类对象
 */
public class ProxyFactory implements MethodInterceptor{
    //维护目标对象
    private Object target;

    public ProxyFactory(Object target) {
        this.target = target;
    }

    //给目标对象创建一个代理对象
    public Object getProxyInstance(){
        //1.工具类
        Enhancer en = new Enhancer();
        //2.设置父类
        en.setSuperclass(target.getClass());
        //3.设置回调函数
        en.setCallback(this);
        //4.创建子类(代理对象)
        return en.create();

    }

    @Override
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        System.out.println("开始事务...");

        //执行目标对象的方法
        Object returnValue = method.invoke(target, args);

        System.out.println("提交事务...");

        return returnValue;
    }
}
```

测试类:

```java
/**
 * 测试类
 */
public class App {

    @Test
    public void test(){
        //目标对象
        UserDao target = new UserDao();

        //代理对象
        UserDao proxy = (UserDao)new ProxyFactory(target).getProxyInstance();

        //执行代理对象的方法
        proxy.save();
    }
}
```

在Spring的AOP编程中:
如果加入容器的目标对象有实现接口,用JDK代理
如果目标对象没有实现接口,用Cglib代理







## 6. 行为型模式

### 模板方法模式

