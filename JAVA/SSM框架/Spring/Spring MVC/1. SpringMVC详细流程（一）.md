Spring Web MVC是一种基于Java的实现了Web MVC设计模式的请求驱动类型的轻量级Web框架，即使用了MVC架构模式的思想，将web层进行职责解耦，基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发，Spring Web MVC也是要简化我们日常Web开发的。
与之相反的是基于组件的、事件驱动的Web框架，如Tapestry、JSF等。
　　Spring Web MVC也是服务到工作者模式的实现，但进行可优化。前端控制器是DispatcherServlet；应用控制器其实拆为处理器映射器(Handler Mapping)进行处理器管理和视图解析器(View Resolver)进行视图管理；页面控制器/动作/处理器为Controller接口（仅包含ModelAndView handleRequest(request, response) 方法）的实现（也可以是任何的POJO类）；支持本地化（Locale）解析、主题（Theme）解析及文件上传等；提供了非常灵活的数据验证、格式化和数据绑定机制；提供了强大的约定大于配置（惯例优先原则）的契约式编程支持。

　　SpringMVC在Web应用中充当控制层（Controller）的角色，对请求进行分发处理。

### 一、Spring请求流程

1. 整体流程

![img](https://bobbo.oss-cn-beijing.aliyuncs.com/img_for_typora/660329-20190922093635656-279038030.png)

 

 具体步骤：

- 首先用户发送请求到前端控制器，前端控制器根据请求信息（如 URL）来决定选择哪一个页面控制器进行处理并把请求委托给它，即以前的控制器的控制逻辑部分；图中的 1、2 步骤；
- 页面控制器接收到请求后，进行功能处理，首先需要收集和绑定请求参数到一个对象，这个对象在 Spring Web MVC 中叫命令对象，并进行验证，然后将命令对象委托给业务对象进行处理；处理完毕后返回一个 ModelAndView（模型数据和逻辑视图名）；图中的 3、4、5 步骤；
- 前端控制器收回控制权，然后根据返回的逻辑视图名，选择相应的视图进行渲染，并把模型数据传入以便视图渲染；图中的步骤 6、7；
- 前端控制器再次收回控制权，将响应返回给用户，图中的步骤 8；至此整个结束。
- 核心流程

![img](https://bobbo.oss-cn-beijing.aliyuncs.com/img_for_typora/660329-20190922093835529-1159443997.png)

具体步骤：

- 第一步：发起请求到前端控制器(DispatcherServlet)
- 第二步：前端控制器请求HandlerMapping查找 Handler （可以根据xml配置、注解进行查找）
- 第三步：处理器映射器HandlerMapping向前端控制器返回Handler，HandlerMapping会把请求映射为HandlerExecutionChain对象（包含一个Handler处理器（页面控制器）对象，多个HandlerInterceptor拦截器对象），通过这种策略模式，很容易添加新的映射策略
- 第四步：前端控制器调用处理器适配器去执行Handler
- 第五步：处理器适配器HandlerAdapter将会根据适配的结果去执行Handler
- 第六步：Handler执行完成给适配器返回ModelAndView
- 第七步：处理器适配器向前端控制器返回ModelAndView （ModelAndView是springmvc框架的一个底层对象，包括 Model和view）
- 第八步：前端控制器请求视图解析器去进行视图解析 （根据逻辑视图名解析成真正的视图(jsp)），通过这种策略很容易更换其他视图技术，只需要更改视图解析器即可
- 第九步：视图解析器向前端控制器返回View
- 第十步：前端控制器进行视图渲染 （视图渲染将模型数据(在ModelAndView对象中)填充到request域）
- 第十一步：前端控制器向用户响应结果

下面我们对出现的一些组件进行详细的介绍：

(1) 前端控制器DispatcherServlet（不需要程序员开发）。
　　作用：接收请求，响应结果，相当于转发器，中央处理器。有了DispatcherServlet减少了其它组件之间的耦合度。
(2) 处理器映射器HandlerMapping（不需要程序员开发）。
　　作用：根据请求的url查找Handler。
(3) 处理器适配器HandlerAdapter（不需要程序员开发）。
　　作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler。
(4) 处理器Handler（需要程序员开发）。
　　注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler
(5) 视图解析器ViewResolver（不需要程序员开发）。
　　作用：进行视图解析，根据逻辑视图名解析成真正的视图（view）
(6) 视图View（需要程序员开发jsp）。
　　注意：View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf…）

ps:不需要程序员开发的，需要程序员自己做一下配置即可。

可以总结出：需要我们开发的工作只有处理器 Handler 的编写以及视图比如JSP页面的编写。可能你还对诸如前端控制器、处理器映射器等等名词不太理解，那么接下来我们对其进行详细的介绍。

### 二、SpringMVC组件配置或开发说明

根据前面所说，部分组件需要配置，部分组件需要程序员开发，接下来就介绍下如何配置和开发相关的组件。

#### 配置前端控制器（DispatcherServlet）

在web project的web.xml中配置：

```
<!-- 配置前端控制器DispatcherServlet -->
<servlet>
    <servlet-name>springmvc</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <!--springmvc.xml 是自己创建的SpringMVC全局配置文件，用contextConfigLocation作为参数名来加载 
        如果不配置 contextConfigLocation，那么默认加载的是/WEB-INF/servlet名称-servlet.xml，在这里也就是 
        springmvc-servlet.xml 参数多个值使用逗号隔开，如：a.xml,b.xml -->
    <init-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath*:springmvc.xml</param-value>
    </init-param>
</servlet>

<servlet-mapping>
    <servlet-name>springmvc</servlet-name>
    <!--第一种配置：*.do,还可以写*.action等等，表示以.do结尾的或者以.action结尾的URL都由前端控制器DispatcherServlet来解析 
        第二种配置：/,所有访问的 URL 都由DispatcherServlet来解析，但是这里最好配置静态文件不由DispatcherServlet来解析，需要对静态资源单独处理 
        错误配置：/*,注意这里是不能这样配置的，因为如果这样写，最后转发到 jsp 页面的时候，仍然会由DispatcherServlet进行解析， 而这时候会找不到对应的Handler，从而报404！！！ -->
    <url-pattern>*.do</url-pattern>
</servlet-mapping>
```

#### 配置处理器映射器（HandlerMapping）

在 springmvc.xml 文件中配置。通俗来讲就是请求的 URL 怎么能被 SpringMVC 识别，从而去执行我们编写好的 Handler。

(1) 第一种方法

```
<!-- 配置Handler -->   
<bean name="/hello.do" class="com.asiainfo.spring.controller.HelloController" />
 
<!-- 配置处理器映射器 将bean的name作为url进行查找，需要在配置Handler时指定bean name（就是url）-->
<bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping" />
```

这样配置的话，那么请求的 URL，必须为 http://ip:port/项目名/hello.do

(2) 第二种方法

```
<!-- 配置Handler -->   
<bean id="hello" class="com.asiainfo.spring.controller.HelloController" />
<bean id="hello2" class="com.asiainfo.spring.controller.HelloController2" />
<!-- 简单URL配置处理器映射器 -->
<bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping">
    <property name="mappings">
        <props>
            <prop key="/hello.do">hello</prop>
            <prop key="/hello2.do">hello2</prop>
        </props>
    </property>
</bean>
```

这种配置请求的 URL可以为 http://ip:prot/项目名/hello.do，或者http://ip:port/项目名/hello2.do

注：上面两种处理器映射器配置可以并存，前端控制器会正确的去判断 url 用哪个 Handler 去处理。

#### 配置处理器适配器（HandlerAdapter）

在 springmvc.xml 文件中配置。用来约束我们所需要编码的 Handler类。

第一种配置：编写 Handler 时必须要实现 Controller，否则不能被适配器解析。

```
<!-- 配置处理器适配器，所有适配器都得实现 HandlerAdapter接口 -->
<bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter" />
```

第二种配置：编写 Handler 时必须要实现 HttpRequestHandler

```
<!-- 配置处理器适配器第二种方法，所有适配器都得实现 HandlerAdapter接口 ，这样配置所有Handler都必须实现 HttpRequestHandler接口-->
<bean class="org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter" />
```

#### 开发处理器（Handler，即我们的Controller）

在 springmvc.xml 文件中配置。通俗来讲，就是请求的 URL 到我们这里所编写的 Handler 类的某个方法进行一些业务逻辑处理。
我们在上面讲解了两个处理器适配器来约束 Handler，那么我们就通过上面两种配置分别编写两个 Handler：

(1) 第一种：实现Controller 接口

```
public class HelloController implements Controller {

    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
        ModelAndView modelView = new ModelAndView();
        modelView.setViewName("/WEB-INF/jsp/index.jsp");
        return modelView;
    }
}
```

(2) 第二种：实现 HttpRequestHandler 接口

```
public class HelloController2 implements HttpRequestHandler {
    public void handleRequest(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        request.setAttribute("name", "harvey");
        request.getRequestDispatcher("/WEB-INF/jsp/index.jsp").forward(request, response);
    }
}
```

通常我们使用第一种方式来编写 Handler ，但是第二种没有返回值，我们可以通过 response 修改相应内容，比如返回 json 数据：
response.setCharacterEncoding("utf-8");
response.setContentType("application/json;charset=utf-8");
response.getWriter().write("json字符串");

所以具体使用哪一种根据实际情况来判断。

5. 配置视图解析器（ViewResolver）

第一种配置：

```
<!-- 配置视图解析器 进行jsp解析，默认使用jstl标签，classpath下得有jstl的包-->
<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver" />
```

如果这样配，那么在 Handler 中返回的必须是路径+jsp页面名称+".jsp"

第二种配置：

```
<!--配置视图解析器  -->
<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
    <!-- 返回视图页面的前缀 -->
    <property name="prefix" value="/WEB-INF/jsp/"></property>
    <!-- 返回页面的后缀 -->
    <property name="suffix" value=".jsp"></property>
</bean>
```

如果这样配，那么在 Handler 中只需要返回在 jsp 文件夹下的jsp 页面名就可以了。

6. DispatcherServlet.properties

上面我们讲解了各种配置，可能有人会问这么多配置，万一少配置了一样，那不就不能运行了，那我们能不能不配置呢？答案是肯定的，SpringMVC 给我们提供了一个 DispatcherServlet.properties 文件。系统会首先加载这里面的配置，如果我们没有配置，那么就默认使用这个文件的配置；如果我们配置了，那么就优先使用我们手动配置的。

在 SpringMVC 运行之前，会首先加载 DispatcherServlet.properties 文件里面的内容
①、处理器适配器默认：org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter
②、处理器映射器默认：org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping
③、视图解析器默认：org.springframework.web.servlet.view.InternalResourceViewResolver





### 三、 几个典型请求流程示例

在 Spring MVC 中，视图解析器（View Resolver）用于将控制器返回的逻辑视图名称解析为实际的视图（如 JSP、Thymeleaf、Freemarker 等）。Spring 提供了多种视图解析器，以下是常见的几种类型：

### 1. **InternalResourceViewResolver (用于 JSP)**

InternalResourceViewResolver 是最常用于 JSP 的视图解析器，将逻辑视图名称解析为 JSP 页面路径。

#### 配置：

```xml
<bean>
  class="org.springframework.web.servlet.view.InternalResourceViewResolver">
    <property name="prefix" value="/WEB-INF/jsp/"/>
    <property name="suffix" value=".jsp"/>
</bean>
```

#### 控制器代码：

```
@Controller
public class WelcomeController {

    @RequestMapping("/welcome")
    public String welcome(Model model) {
        model.addAttribute("message", "Welcome to JSP!");
        return "welcome";  // 解析为 /WEB-INF/jsp/welcome.jsp
    }
}
```

#### JSP 页面：

`/WEB-INF/jsp/welcome.jsp`：

```
<%@ page contentType="text/html;charset=UTF-8" %>
<html>
<head>
    <title>Welcome Page</title>
</head>
<body>
    <h1>${message}</h1>  //jsp的el表达式
</body>
</html>
```





### 2. **ThymeleafViewResolver (用于 Thymeleaf)**



[Thymeleaf教程（10分钟入门）](https://blog.csdn.net/youandme520/article/details/122850538?fromshare=blogdetail&sharetype=blogdetail&sharerId=122850538&sharerefer=PC&sharesource=qq_45760067&sharefrom=from_link)

如果使用 Thymeleaf 模板引擎，可以使用 `ThymeleafViewResolver`。

Thymeleaf 是一个用于 Java Web 应用的模板引擎，常用于生成动态 HTML 页面

#### 配置：

```
xml复制代码<bean id="thymeleafViewResolver" class="org.thymeleaf.spring5.view.ThymeleafViewResolver">
    <property name="templateEngine" ref="templateEngine"/>
    <property name="order" value="1"/>
    <property name="viewNames" value="*.html"/>
</bean>

<bean id="templateEngine" class="org.thymeleaf.spring5.SpringTemplateEngine">
    <property name="templateResolver" ref="templateResolver"/>
</bean>

<bean id="templateResolver" class="org.thymeleaf.templateresolver.ServletContextTemplateResolver">
    <property name="prefix" value="/WEB-INF/templates/"/>
    <property name="suffix" value=".html"/>
    <property name="templateMode" value="HTML5"/>
</bean>
```

#### 控制器代码：

```
java复制代码@Controller
public class WelcomeController {

    @RequestMapping("/welcome")
    public String welcome(Model model) {
        model.addAttribute("message", "Welcome to Thymeleaf!");
        return "welcome";  // 解析为 /WEB-INF/templates/welcome.html
    }
}
```

#### Thymeleaf 页面：

`/WEB-INF/templates/welcome.html`：

```
html复制代码<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <title>Welcome Page</title>
</head>
<body>
    <h1 th:text="${message}">Welcome!</h1> //Thymeleaf 也有自己的解析表达式
</body>
</html>
```



### 3. 两者对比

> Thymeleaf 和 JSP（Java Server Pages）都是用于 Java Web 应用的视图模板引擎，但它们的出现时间和设计理念有较大区别：
>
> ### 时间顺序
>
> - **JSP** 是较早的技术，**推出于 1999 年**，是 Java EE（现为 Jakarta EE）标准的一部分。JSP 作为一种动态网页技术，允许开发者在 HTML 页面中嵌入 Java 代码。
> - **Thymeleaf** 是一个相对较新的模板引擎，**诞生于 2011 年左右**。它并不属于 Java EE 标准，而是一个独立的开源项目，专门为现代 Web 开发设计，尤其是 Spring 框架用户。
>
> 因此，**JSP 是先于 Thymeleaf 出现的**。
>
> ### 设计理念和特点
>
> #### 1. **JSP（Java Server Pages）**
>
> - **基于 Servlet 技术**：JSP 是一种以 Servlet 为基础的视图技术，允许在 HTML 页面中直接嵌入 Java 代码。
> - **原理**：JSP 文件在第一次请求时会被编译为 Servlet，并在每次请求时通过生成 HTML 响应。
> - **语法混杂**：JSP 允许使用 Java 代码（例如 `<% %>` 中的 Java 表达式和语句），导致页面逻辑和视图代码混杂，难以维护。
> - **传统**：JSP 是 Java EE 中最早的模板引擎之一，曾经非常流行，尤其在早期的 Java Web 应用开发中。
>
> #### 2. **Thymeleaf**
>
> - **面向现代 Web 开发**：Thymeleaf 的设计理念更现代，提供了一种清晰的、基于 HTML 模板的开发方式，适合开发者直接在 HTML 页面中编写逻辑。
> - **纯 HTML 模板**：Thymeleaf 提倡“自然模板”概念，即模板文件可以直接在浏览器中作为普通 HTML 文件查看。这意味着即使不运行服务器，设计师和开发者也可以看到静态页面，而 JSP 文件不能直接在浏览器中查看。
> - **强大的表达式语言（OGNL 或 Spring EL）**：Thymeleaf 使用表达式语言从 Java 对象中提取数据，避免了 JSP 中直接嵌入 Java 代码的做法，使得代码更加简洁和可维护。
> - **与 Spring 集成**：Thymeleaf 尤其适合与 Spring 框架（尤其是 Spring Boot）集成，官方文档和支持非常完善，开发体验良好。
>
> ### 对比总结
>
> - **时间上**：JSP 比 Thymeleaf 早了十多年。
> - **设计理念**：JSP 强调通过嵌入 Java 代码来动态生成内容，而 Thymeleaf 更倾向于通过简洁的表达式语言来处理数据，注重与 HTML 语法的兼容性和可维护性。
> - **适用场景**：JSP 更适合传统的 Java EE 应用，而 Thymeleaf 更适合与 Spring 这样的现代 Web 框架结合。
>
> 如今，JSP 的使用已经明显减少，而 Thymeleaf 由于其易用性和与 Spring 的良好集成，在现代 Spring Boot 项目中使用非常广泛



### 4. 前后端分离

在 Thymeleaf 之后，Web 开发领域出现了许多新的前端和后端技术，尤其随着前后端分离的架构趋势发展，更多强调前端开发的框架和工具得到了广泛使用。

在 Thymeleaf 之后，前端技术的发展迅猛，尤其是随着 **单页应用（SPA）** 和 **前后端分离** 的趋势，像 **React**、**Vue.js** 和 **Angular** 等现代前端框架逐渐取代了传统的模板引擎。

在前后端分离架构中，后端通常通过 API 向前端传递 **JSON**（JavaScript Object Notation）格式的数据。这是因为 JSON 具有简洁、易读、易解析等特点，非常适合作为前后端之间数据传递的格式。

> ### 为什么使用 JSON 格式？
>
> 1. **轻量化**：JSON 是一种非常轻量级的数据交换格式，比 XML 等格式更简洁。
> 2. **可读性好**：JSON 的结构非常接近 JavaScript 对象，易于前端开发者理解和处理。
> 3. **易解析**：JavaScript 原生支持 JSON 格式，现代 Web 浏览器提供了方便的 `JSON.parse()` 和 `JSON.stringify()` 方法，轻松将 JSON 转换为 JavaScript 对象或字符串，后端语言如 Java、Python 等也提供了丰富的 JSON 库。
> 4. **跨语言支持**：JSON 是一种通用的格式，不仅 JavaScript，其他编程语言如 Java、Python、Go 等都可以轻松解析和生成 JSON 数据。
