https://www.cnblogs.com/snow-flower/p/6114765.html

# 1. 编程基础

## 1.1 进程和线程

### 进程 

当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程

进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器 等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）

> 程序变成进程的过程是将程序的所有部分加载到内存中，而不是将指令直接放到 CPU。具体步骤如下：
>
> 1. **加载程序**：操作系统将程序的指令和数据从存储设备（如硬盘）加载到内存中。这包括程序代码、全局变量、堆和栈等。
> 2. **创建进程**：操作系统为这个程序分配一个进程控制块（PCB），包含进程状态、资源信息等。
> 3. **分配 CPU**：一旦进程在内存中，操作系统会调度 CPU 来执行这个进程的指令。CPU 会从内存中获取指令并执行，而不是直接将指令放入 CPU 中。
>
> 所以，整体流程是程序的指令和数据都被加载到内存，之后 CPU 通过内存来执行指令。



### 线程 

一个进程之内可以分为一到多个线程。 

一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 



### 二者对比 

进程负责资源管理，但真正的活动和执行是通过线程来实现的。

进程基本上相互独立的，而线程存在于进程内，是进程的一个子集 

- 进程拥有共享的资源，如内存空间等，供其内部的线程共享 进程间通信较为复杂 同一台计算机的进程通信称为 IPC（Inter-process communication）
	- 信号量：信号量是一个计数器，用于多进程对共享数据的访问，解决同步相关的问题并避免竞争条件
	- 共享存储：多个进程可以访问同一块内存空间，需要使用信号量用来同步对共享存储的访问
	- 管道通信：管道是用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件 pipe 文件，该文件同一时间只允许一个进程访问，所以只支持**半双工通信**
		* 匿名管道（Pipes）：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信
		* 命名管道（Names Pipes）：以磁盘文件的方式存在，可以实现本机任意两个进程通信，遵循 FIFO
	- 消息队列：（比如说mq）内核中存储消息的链表，由消息队列标识符标识，能在不同进程之间提供**全双工通信**，对比管道：
		* 匿名管道存在于内存中的文件；命名管道存在于实际的磁盘介质或者文件系统；消息队列存放在内核中，只有在内核重启（操作系统重启）或者显示地删除一个消息队列时，该消息队列才被真正删除
		* 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收

- 不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP 
	- 套接字：与其它通信机制不同的是，可用于不同机器间的互相通信

- 线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量 

​	**Java 中的通信机制**：volatile、等待/通知机制、join 方式、InheritableThreadLocal、MappedByteBuffer

- 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低

线程的作用：使多道程序更好的并发执行，提高资源利用率和系统吞吐量，增强操作系统的并发性能

> 在单线程系统中，进程负责资源管理，而唯一的线程负责执行所有的任务。在这种情况下，进程内只有一个线程，因此所有的指令流都由这个线程顺序执行。尽管没有多线程的并发执行，但进程仍然提供所需的资源和环境支持，确保线程能够有效地运行。



## 1.2 并行和并发

并发并行：

* 并行：在同一时刻，有多个指令在多个 CPU 上同时执行
* 并发：在同一时刻，有多个指令在单个 CPU 上交替执行

单核 cpu 下，线程实际还是 串行执行 的。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows 下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于 cpu 在线程间（时间片很短）的切换非常快，人类感觉是 同时运行的 。总结为一句话就是： 微观串行，宏观并行 ， 一般会将这种线程轮流使用 CPU 的做法称为并发concurrent

多核 cpu下，每个 核（core） 都可以调度运行线程，这时候线程可以是并行的。

同步异步：

* 需要等待结果返回，才能继续运行就是同步
* 不需要等待结果返回，就能继续运行就是异步

> **cpu的核心与线程**
>
> 　对于一个CPU，线程数总是大于或等于核心数的。一个核心最少对应一个线程，但通过**超线程技术(Intel)/SMT 技术(AMD)**，一个核心可以对应两个线程，也就是说它可以同时运行两个线程。每个物理核心拥有两个逻辑核心，能够处理两个线程。当一个线程在等待 I/O 操作或资源时，另一个线程可以利用该核心的计算能力，从而减少 CPU 的空闲时间。
>
> 通过使用超线程技术，在一个物理核心上同时处理两个线程可以被视为 **并行** 执行。
>
> 

如果程序是采用多线程的技术编写的，那么运行在单核单线程的机器上，就会并发执行；运行在多核多线程的机器上，就会并行执行。

# 2. java线程基础

## 2.1 创建线程

### 继承Thread类

自定义线程类继承Thread类

重写run方法，编写线程执行体

创建线程对象，调用start()方法启动线程（注意：线程开启不一定立即执行，cpu安排调度）

```java
public class ThreadTest extends Thread{
    @Override
    public void run() {
        for (int i = 0; i < 200; i++) {
            System.out.println("我在子线程里");
        }
    }

    public static void main(String[] args) {
        ThreadTest threadTest = new ThreadTest();
        threadTest.start();
        for (int i = 0; i < 2000; i++) {
            System.out.println("我在主线程里-----------------------");
        }
    }
}
```

不建议使用，避免单继承局限性

### 实现Runnable接口

自定义实现类实现Runnable接口

实现run接口，编写线程执行体 

创建线程对象，将接口实现类传入线程对象的构造器，调用start()方法启动线程

```java
public class test2 implements Runnable{
    @Override
    public void run() {
        for (int i = 0; i < 200; i++) {
            System.out.println("我在子线程里");
        }
    }

    public static void main(String[] args) {
        // 创建Runnable接口的实现类
        test2 test2 = new test2();
        // 创建Thread类对象，构造方法中传递Runnable接口实现类对象
        Thread thread = new Thread(test2);
        // 调用start方法开启线程
        thread.start();
        
       
        for (int i = 0; i < 1000; i++) {
            System.out.println("我在主线程里------------------------------------");
        }

    }

}
```

推荐使用：避免单继承局限性，精活方便，方便一个对象被多个线程复用,共享资源

```java
 //方便复用
         // 创建Runnable接口的实现类
        test2 test2 = new test2();
        Thread thread = new Thread(test2);
        Thread thread1 = new Thread(test2);
```



### 实现Callable接口（了解）



### 2.2 线程的生命周期

![image-20241206192338104](https://bobbo.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20241206192338104.png)



**1、新建状态**

​    用new关键字和Thread类或其子类建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用start方法进入就绪状态（runnable）。

注意：不能对已经启动的线程再次调用start()方法，否则会出现[Java](http://lib.csdn.net/base/17).lang.IllegalThreadStateException异常。

**2、就绪状态**

​    处于就绪状态的线程已经具备了运行条件，但还没有分配到CPU，处于线程就绪队列（尽管是采用队列形式，事实上，把它称为可运行池而不是可运行队列。因为cpu的调度不一定是按照先进先出的顺序来调度的），等待系统为其分配CPU。等待状态并不是执行状态，当系统选定一个等待执行的Thread对象后，它就会从等待执行状态进入执行状态，系统挑选的动作称之为“cpu调度”。一旦获得CPU，线程就进入运行状态并自动调用自己的run方法。

提示：如果希望子线程调用start()方法后立即执行，可以使用Thread.sleep()方式使主线程睡眠一伙儿，转去执行子线程。

**3、运行状态**

   处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。**
**

处于就绪状态的线程，如果获得了cpu的调度，就会从就绪状态变为运行状态，执行run()方法中的任务。如果该线程失去了cpu资源，就会又从运行状态变为就绪状态。重新等待系统分配资源。也可以对在运行状态的线程调用yield()方法，它就会让出cpu资源，再次变为就绪状态。

注： 当发生如下情况是，线程会从运行状态变为阻塞状态：

   ①、线程调用sleep方法主动放弃所占用的系统资源

   ②、线程调用一个阻塞式IO方法，在该方法返回之前，该线程被阻塞

   ③、线程试图获得一个同步监视器，但更改同步监视器正被其他线程所持有

   ④、线程在等待某个通知（notify）

   ⑤、程序调用了线程的suspend方法将线程挂起。不过该方法容易导致死锁，所以程序应该尽量避免使用该方法。

当线程的run()方法执行完，或者被强制性地终止，例如出现异常，或者调用了stop()、desyory()方法等等，就会从运行状态转变为死亡状态。

**4、阻塞状态**

   处于运行状态的线程在某些情况下，如执行了sleep（睡眠）方法，或等待I/O设备等资源，将让出CPU并暂时停止自己的运行，进入阻塞状态。 

在阻塞状态的线程不能进入就绪队列。只有当引起阻塞的原因消除时，如睡眠时间已到，或等待的I/O设备空闲下来，线程便转入就绪状态，重新到就绪队列中排队等待，被系统选中后从原来停止的位置开始继续运行。有三种方法可以暂停Threads执行：

**5、死亡状态**

   当线程的run()方法执行完，或者被强制性地终止，就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。 如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。

### 2.3 线程管理

Java提供了一些便捷的方法用于会线程状态的控制。具体如下：

#### **1、线程睡眠——sleep**

   如果我们需要让当前正在执行的线程暂停一段时间，并进入阻塞状态，则可以通过调用Thread的sleep方法。

**注：**

  **（1）**sleep是静态方法，最好不要用Thread的实例对象调用它，因为它睡眠的始终是当前正在运行的线程，而不是调用它的线程对象，它只对正在运行状态的线程对象有效。

```java
public class Test1 {  
    public static void main(String[] args) throws InterruptedException {  
        System.out.println(Thread.currentThread().getName());  
        MyThread myThread=new MyThread();  
        myThread.start();  
        myThread.sleep(1000);//这里sleep的就是main线程，而非myThread线程  
        Thread.sleep(10);  
        for(int i=0;i<100;i++){  
            System.out.println("main"+i);  
        }  
    }  
} 
```

**（2）**Java线程调度是Java多线程的核心，只有良好的调度，才能充分发挥系统的性能，提高程序的执行效率。但是不管程序员怎么编写调度，只能最大限度的影响线程执行的次序，而不能做到精准控制。因为使用sleep方法之后，线程是进入阻塞状态的，只有当睡眠的时间结束，才会重新进入到就绪状态，而就绪状态进入到运行状态，是由系统控制的，我们不可能精准的去干涉它，所以如果调用Thread.sleep(1000)使得线程睡眠1秒，可能结果会大于1秒。

#### **2、线程让步——yield**

   yield()方法和sleep()方法有点相似，它也是Thread类提供的一个静态的方法，它也可以让当前正在执行的线程暂停，让出cpu资源给其他的线程。但是和sleep()方法不同的是，它不会进入到阻塞状态，而是进入到就绪状态。yield()方法只是让当前线程暂停一下，重新进入就绪的线程池中，让系统的线程调度器重新调度器重新调度一次，完全可能出现这样的情况：当某个线程调用yield()方法之后，线程调度器又将其调度出来重新进入到运行状态执行。

实际上，当某个线程调用了yield()方法暂停之后，优先级与当前线程相同，或者优先级比当前线程更高的就绪状态的线程更有可能获得执行的机会，当然，只是有可能，因为我们不可能精确的干涉cpu调度线程。用法如下：

```java
public class Test1 {  
    public static void main(String[] args) throws InterruptedException {  
        new MyThread("低级", 1).start();  
        new MyThread("中级", 5).start();  
        new MyThread("高级", 10).start();  
    }  
}  
  
class MyThread extends Thread {  
    public MyThread(String name, int pro) {  
        super(name);// 设置线程的名称  
        this.setPriority(pro);// 设置优先级  
    }  
  
    @Override  
    public void run() {  
        for (int i = 0; i < 30; i++) {  
            System.out.println(this.getName() + "线程第" + i + "次执行！");  
            if (i % 5 == 0)  
                Thread.yield();  
        }  
    }  
} 
```

**注：**关于sleep()方法和yield()方的区别如下：

①、sleep方法暂停当前线程后，会进入阻塞状态，只有当睡眠时间到了，才会转入就绪状态。而yield方法调用后 ，是直接进入就绪状态，所以有可能刚进入就绪状态，又被调度到运行状态。

②、sleep方法声明抛出了InterruptedException，所以调用sleep方法的时候要捕获该异常，或者显示声明抛出该异常。而yield方法则没有声明抛出任务异常。

③、sleep方法比yield方法有更好的可移植性，通常不要依靠yield方法来控制并发线程的执行。

#### **3、线程合并——join**

用于让当前线程等待另一个线程执行完毕后再继续运行。通过调用某个线程的 `join` 方法，可以让当前线程**合并**到目标线程的执行流程中。应用场景是当一个线程必须等待另一个线程执行完毕才能执行时，Thread类提供了join方法来完成这个功能，注意，它不是静态方法。

从上面的方法的列表可以看到，它有3个重载的方法：

```java
void join()      
     当前线程等该加入该线程后面，等待该线程终止。    
void join(long millis)   //带超时的 如果线程在指定时间内没有结束，当前线程将恢复运行，不再继续等待
     当前线程等待该线程终止的时间最长为 millis 毫秒。 
void join(long millis,int nanos)   
     等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒
```

```java
class MyThread extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println(Thread.currentThread().getName() + " is running: " + i);
            try {
                Thread.sleep(500); // 模拟线程工作，睡眠 500 毫秒
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

public class TestJoin {
    public static void main(String[] args) throws InterruptedException {
        MyThread myThread = new MyThread();
        myThread.start(); // 启动线程

        System.out.println("Main thread is waiting for MyThread to finish...");
        myThread.join(); // 主线程等待 myThread 线程执行完毕
        System.out.println("MyThread has finished. Main thread continues...");
    }
}

```

#### **4、设置线程的优先级**

   每个线程执行时都有一个优先级的属性，优先级高的线程可以获得较多的执行机会，而优先级低的线程则获得较少的执行机会。与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线程获取CPU资源的概率较大，优先级低的也并非没机会执行。

每个线程默认的优先级都与创建它的父线程具有相同的优先级，在默认情况下，main线程具有普通优先级。

**注：**Thread类提供了setPriority(int newPriority)和getPriority()方法来设置和返回一个指定线程的优先级，其中setPriority方法的参数是一个整数，范围是1~10之间，也可以使用Thread类提供的三个静态常量：

```
MAX_PRIORITY   =10

MIN_PRIORITY   =1

NORM_PRIORITY   =5 //默认优先级
```

```java
public class Test1 {  
        public static void main(String[] args) throws InterruptedException {  
            new MyThread("高级", 10).start();  
            new MyThread("低级", 1).start();  
        }  
    }  
      
    class MyThread extends Thread {  
        public MyThread(String name,int pro) {  
            super(name);//设置线程的名称  
            setPriority(pro);//设置线程的优先级  
        }  
        @Override  
        public void run() {  
            for (int i = 0; i < 100; i++) {  
                System.out.println(this.getName() + "线程第" + i + "次执行！");  
            }  
        }  
    }  
```

**注：**虽然Java提供了10个优先级别，但这些优先级别需要操作系统的支持。不同的操作系统的优先级并不相同，而且也不能很好的和Java的10个优先级别对应。所以我们应该使用MAX_PRIORITY、MIN_PRIORITY和NORM_PRIORITY三个静态常量来设定优先级，这样才能保证程序最好的可移植性。



#### 5、后台（守护）线程



   守护线程使用的情况较少，但并非无用，举例来说，JVM的垃圾回收、内存管理等线程都是守护线程。还有就是在做数据库应用时候，使用的数据库连接池，连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等。调用线程对象的方法setDaemon(true)，则可以将其设置为守护线程。守护线程的用途为：

   • 守护线程通常用于执行一些后台作业，例如在你的应用程序运行时播放背景音乐，在文字编辑器里做自动语法检查、自动保存等功能。

   • Java的垃圾回收也是一个守护线程。守护线的好处就是你不需要关心它的结束问题。例如你在你的应用程序运行的时候希望播放背景音乐，如果将这个播放背景音乐的线程设定为非守护线程，那么在用户请求退出的时候，不仅要退出主线程，还要通知播放背景音乐的线程退出；如果设定为守护线程则不需要了。

setDaemon方法的详细说明：

```java
class MyDaemonThread extends Thread {
    @Override
    public void run() {
        while (true) {
            System.out.println(Thread.currentThread().getName() + " is running...");
            try {
                Thread.sleep(1000); // 模拟后台工作
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

public class DaemonThreadExample {
    public static void main(String[] args) {
        MyDaemonThread daemonThread = new MyDaemonThread();
        daemonThread.setDaemon(true); // 设置为守护线程
        daemonThread.start();

        System.out.println("Main thread is running...");
        try {
            Thread.sleep(5000); // 模拟主线程工作
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("Main thread ends. JVM will exit now.");
    }
}

```

**注：**JRE判断程序是否执行结束的标准是所有的前台执线程行完毕了，而不管后台线程的状态，因此，在使用后台县城时候一定要注意这个问题**。**

#### **6、正确结束线程**

Thread.stop()、Thread.suspend、Thread.resume、Runtime.runFinalizersOnExit这些终止线程运行的方法已经被废弃了，使用它们是极端不安全的！想要安全有效的结束一个线程，可以使用下面的方法：

  • 正常执行完run方法，然后结束掉；

  • 控制循环条件和判断条件的标识符来结束掉线程。

```java
class MyThread extends Thread {  
    int i=0;  
    boolean next=true;  
    @Override  
    public void run() {  
        while (next) {  
            if(i==10)  
                next=false;  
            i++;  
            System.out.println(i);  
        }  
    }  
}
```



### 2.4 线程同步

   java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查），将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。

#### **1、同步方法**   

   即有synchronized关键字修饰的方法。由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。

```
public synchronized void save(){}
```

 **注：** synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类



#### **2、同步代码块**   

   即有synchronized关键字修饰的语句块。被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。

```
synchronized (lockObject) {
    // 需要加锁的代码块
}
```

- `lockObject`

  ：指定的锁对象，任何对象都可以作为锁对象。

  - 如果不同线程使用的是**不同的锁对象**，那么它们的同步就不会互相影响。
  - 如果使用的是**同一个锁对象**，线程间就会形成互斥。

```java
public class Bank {  
     
        private int count =0;//账户余额  
     
        //存钱  
        public   void addMoney(int money){  
     
            synchronized (this) {  
                count +=money;  
            }  
            System.out.println(System.currentTimeMillis()+"存进："+money);  
        }  
     
        //取钱  
        public   void subMoney(int money){  
     
            synchronized (this) {  //锁对象是 this（当前实例）。
                if(count-money < 0){  
                    System.out.println("余额不足");  
                    return;  
                }  
                count -=money;  
            }  
            System.out.println(+System.currentTimeMillis()+"取出："+money);  
        }  
     
        //查询  
        public void lookMoney(){  
            System.out.println("账户余额："+count);  
        }
    }
```

**注：**同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。

 **锁的粒度**

**使用 `this` 作为锁：**

- 锁的作用范围较大，锁住的是整个对象（`this`）。
- 如果该对象的其他代码（在类的其他部分）也使用了 `synchronized(this)`，那么它们会互相影响。
- 同一个对象的多个同步代码块**共享同一把锁**，可能导致不必要的竞争。

**使用 `private final Object lock` 作为锁：**

- 锁的作用范围较小，锁住的是这个单独定义的 `lock` 对象。
- 其他代码即使使用 `synchronized(this)`，也不会与此锁发生竞争。
- 锁的粒度更细，避免了不必要的锁竞争。

```java
//使用 this 作为锁
class SharedResource {
    public void method1() {
        synchronized (this) {
            System.out.println(Thread.currentThread().getName() + " is executing method1");
            try {
                Thread.sleep(1000); // 模拟任务耗时
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            System.out.println(Thread.currentThread().getName() + " finished method1");
        }
    }

    public void method2() {
        synchronized (this) {
            System.out.println(Thread.currentThread().getName() + " is executing method2");
            try {
                Thread.sleep(1000); // 模拟任务耗时
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            System.out.println(Thread.currentThread().getName() + " finished method2");
        }
    }
}
//method1 和 method2 都使用 this 作为锁。
//同一时间只有一个线程能执行 method1 或 method2，因为它们竞争的是同一把锁（即 this）
```

```java
//使用特定锁对象
class SharedResource {
    private final Object lock1 = new Object();
    private final Object lock2 = new Object();

    public void method1() {
        synchronized (lock1) {
            System.out.println(Thread.currentThread().getName() + " is executing method1");
            try {
                Thread.sleep(1000); // 模拟任务耗时
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            System.out.println(Thread.currentThread().getName() + " finished method1");
        }
    }

    public void method2() {
        synchronized (lock2) {
            System.out.println(Thread.currentThread().getName() + " is executing method2");
            try {
                Thread.sleep(1000); // 模拟任务耗时
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            System.out.println(Thread.currentThread().getName() + " finished method2");
        }
    }
}
//method1 和 method2 使用了不同的锁对象（lock1 和 lock2）。
//两个方法可以被不同的线程同时执行，不会互相影响，因为它们竞争的是不同的锁。
```





####  **3、使用特殊域变量(volatile)实现线程同步**    

  • volatile关键字为域变量的访问提供了一种免锁机制：与 `synchronized` 关键字不同，`volatile` 不需要加锁或上下文切换，不会引发线程阻塞。

  • volatile不会提供任何原子操作，它也不能用来修饰final类型的变量

它告诉 **Java 虚拟机（JVM）**，该变量可能会被**多个线程修改**，所以**线程每次访问该变量时必须直接从主内存中读取最新值**。

```java
 public class SynchronizedThread {
 
        class Bank {
 
            private volatile int account = 100;
 
            public int getAccount() {
                return account;
            }
 
            /**
             * 用同步方法实现
             * 
             * @param money
             */
            public synchronized void save(int money) {
                account += money;
            }
 
            /**
             * 用同步代码块实现
             * 
             * @param money
             */
            public void save1(int money) {
                synchronized (this) {
                    account += money;
                }
            }
        }
 
        class NewThread implements Runnable {
            private Bank bank;
 
            public NewThread(Bank bank) {
                this.bank = bank;
            }
 
            @Override
            public void run() {
                for (int i = 0; i < 10; i++) {
                    // bank.save1(10);
                    bank.save(10);
                    System.out.println(i + "账户余额为：" +bank.getAccount());
                }
            }
 
        }
 
        /**
         * 建立线程，调用内部类
         */
        public void useThread() {
            Bank bank = new Bank();
            NewThread new_thread = new NewThread(bank);
            System.out.println("线程1");
            Thread thread1 = new Thread(new_thread);
            thread1.start();
            System.out.println("线程2");
            Thread thread2 = new Thread(new_thread);
            thread2.start();
        }
 
        public static void main(String[] args) {
            SynchronizedThread st = new SynchronizedThread();
            st.useThread();
        }
```





#### **4、使用重入锁（Lock）实现线程同步**

   在[Java](http://www.2cto.com/kf/ware/Java/)SE5.0中新增了一个java.util.concurrent包来支持同步。ReentrantLock类是可重入、互斥、实现了Lock接口的锁，它与使用synchronized方法和块具有相同的基本行为和语义，并且扩展了其能力。ReenreantLock类的常用方法有： 

```java
import java.util.concurrent.locks.ReentrantLock;

class SafeCounter {
    private int count = 0;
    private final ReentrantLock lock = new ReentrantLock(); // 创建重入锁

    public void increment() {
        lock.lock(); // 获取锁
        try {
            count++;
        } finally {
            lock.unlock(); // 确保锁释放，防止异常导致死锁
        }
    }

    public int getCount() {
        lock.lock();
        try {
            return count;
        } finally {
            lock.unlock();
        }
    }
}

public class ReentrantLockDemo {
    public static void main(String[] args) throws InterruptedException {
        SafeCounter counter = new SafeCounter();

        // 启动多个线程同时对计数器进行操作
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        });

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        });

        t1.start();
        t2.start();

        t1.join();
        t2.join();

        System.out.println("Final Count: " + counter.getCount()); // 结果为 2000
    }
}

```

### 2.5 线程通信

**1、借助于Object类的wait()、notify()和notifyAll()实现通信**

   线程执行wait()后，就放弃了运行资格，处于冻结状态；

   线程运行时，内存中会建立一个线程池，冻结状态的线程都存在于线程池中，notify()执行时唤醒的也是线程池中的线程，线程池中有多个线程时唤醒第一个被冻结的线程。
   notifyall(), 唤醒线程池中所有线程。
**注：** （1） wait(), notify(),notifyall()都用在同步里面，因为这3个函数是对持有锁的线程进行操作，而只有同步才有锁，所以要使用在同步中；
    （2） wait(),notify(),notifyall(), 在使用时必须标识它们所操作的线程持有的锁，因为等待和唤醒必须是同一锁下的线程；而锁可以是任意对象，所以这3个方法都是Object类中的方法。

***\*2、使用Condition控制线程通信\****

   jdk1.5中，提供了多线程的升级解决方案为：

   （1）将同步synchronized替换为显式的Lock操作；

   （2）将Object类中的wait(), notify(),notifyAll()替换成了Condition对象，该对象可以通过Lock锁对象获取;

   （3）一个Lock对象上可以绑定多个Condition对象，这样实现了本方线程只唤醒对方线程，而jdk1.5之前，一个同步只能有一个锁，不同的同步只能用锁来区分，且锁嵌套时容易死锁。

***\*3、使用阻塞队列（BlockingQueue）控制线程通信\****

​    BlockingQueue是一个接口，也是Queue的子接口。**BlockingQueue具有一个特征：**当生产者线程试图向BlockingQueue中放入元素时，如果该队列已满，则线程被阻塞；但消费者线程试图从BlockingQueue中取出元素时，如果队列已空，则该线程阻塞。程序的两个线程通过交替向BlockingQueue中放入元素、取出元素，即可很好地控制线程的通信。

**BlockingQueue提供如下两个支持阻塞的方法：**

 **（1）put(E e)：**尝试把Eu元素放如BlockingQueue中，如果该队列的元素已满，则阻塞该线程。

 **（2）take（）：**尝试从BlockingQueue的头部取出元素，如果该队列的元素已空，则阻塞该线程。

**BlockingQueue继承了Queue接口，当然也可以使用Queue接口中的方法，这些方法归纳起来可以分为如下三组：**

 **（1）**在队列尾部插入元素，包括add（E e）、offer（E e）、put（E e）方法，当该队列已满时，这三个方法分别会抛出异常、返回false、阻塞队列。

 **（2）**在队列头部删除并返回删除的元素。包括remove（）、poll（）、和take（）方法，当该队列已空时，这三个方法分别会抛出异常、返回false、阻塞队列。

 **（3）**在队列头部取出但不删除元素。包括element（）和peek（）方法，当队列已空时，这两个方法分别抛出异常、返回false。

```java
import java.util.concurrent.ArrayBlockingQueue;
 2 import java.util.concurrent.BlockingQueue;
 3 public class BlockingQueueTest{
 4     public static void main(String[] args)throws Exception{
 5         //创建一个容量为1的BlockingQueue
 6         
 7         BlockingQueue<String> b=new ArrayBlockingQueue<>(1);
 8         //启动3个生产者线程
 9         new Producer(b).start();
10         new Producer(b).start();
11         new Producer(b).start();
12         //启动一个消费者线程
13         new Consumer(b).start();
14         
15     }
16 }
17 class Producer extends Thread{
18     private BlockingQueue<String> b;
19     
20     public Producer(BlockingQueue<String> b){
21         this.b=b;
22         
23     }
24     public synchronized void run(){
25         String [] str=new String[]{
26             "java",
27             "struts",
28             "Spring"
29         };
30         for(int i=0;i<9999999;i++){
31             System.out.println(getName()+"生产者准备生产集合元素！");
32             try{
33             
34                 b.put(str[i%3]);
35                 sleep(1000);
36                 //尝试放入元素，如果队列已满，则线程被阻塞
37                 
38             }catch(Exception e){System.out.println(e);}
39             System.out.println(getName()+"生产完成："+b);
40         }
41         
42     }
43 }
44 class Consumer extends Thread{
45     private BlockingQueue<String> b;
46     public Consumer(BlockingQueue<String> b){
47         this.b=b;
48     }
49     public  synchronized  void run(){
50     
51         while(true){
52             System.out.println(getName()+"消费者准备消费集合元素！");
53             try{
54                 sleep(1000);
55                 //尝试取出元素，如果队列已空，则线程被阻塞
56                 b.take();
57             }catch(Exception e){System.out.println(e);}
58             System.out.println(getName()+"消费完："+b);
59         }
60     
61     }
62 }
```



### 2.6 线程池

合理利用线程池能够带来三个好处。

1. 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
2. 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
3. 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

***\*1、使用Executors工厂类产生线程池\****

   Executor线程池框架的最大优点是把任务的提交和执行解耦。客户端将要执行的任务封装成Task，然后提交即可。而Task如何执行客户端则是透明的。具体点讲，提交一个Callable对象给ExecutorService（如最常用的线程池ThreadPoolExecutor），将得到一个Future对象，调用Future对象的get方法等待执行结果。

**（1）使用Executors的静态工厂类创建线程池的方法如下：**

```
1、newFixedThreadPool() ： 
   作用：该方法返回一个固定线程数量的线程池，该线程池中的线程数量始终不变，即不会再创建新的线程，也不会销毁已经创建好的线程，自始自终都是那几个固定的线程在工作，所以该线程池可以控制线程的最大并发数。 
栗子：假如有一个新任务提交时，线程池中如果有空闲的线程则立即使用空闲线程来处理任务，如果没有，则会把这个新任务存在一个任务队列中，一旦有线程空闲了，则按FIFO方式处理任务队列中的任务。
2、newCachedThreadPool() ： 
   作用：该方法返回一个可以根据实际情况调整线程池中线程的数量的线程池。即该线程池中的线程数量不确定，是根据实际情况动态调整的。 
栗子：假如该线程池中的所有线程都正在工作，而此时有新任务提交，那么将会创建新的线程去处理该任务，而此时假如之前有一些线程完成了任务，现在又有新任务提交，那么将不会创建新线程去处理，而是复用空闲的线程去处理新任务。那么此时有人有疑问了，那这样来说该线程池的线程岂不是会越集越多？其实并不会，因为线程池中的线程都有一个“保持活动时间”的参数，通过配置它，如果线程池中的空闲线程的空闲时间超过该“保存活动时间”则立刻停止该线程，而该线程池默认的“保持活动时间”为60s。
3、newSingleThreadExecutor() ： 
   作用：该方法返回一个只有一个线程的线程池，即每次只能执行一个线程任务，多余的任务会保存到一个任务队列中，等待这一个线程空闲，当这个线程空闲了再按FIFO方式顺序执行任务队列中的任务。
4、newScheduledThreadPool() ： 
   作用：该方法返回一个可以控制线程池内线程定时或周期性执行某任务的线程池。
5、newSingleThreadScheduledExecutor() ： 
   作用：该方法返回一个可以控制线程池内线程定时或周期性执行某任务的线程池。只不过和上面的区别是该线程池大小为1，而上面的可以指定线程池的大小。

**注：**Executors只是一个工厂类，它所有的方法返回的都是`ThreadPoolExecutor`、`ScheduledThreadPoolExecutor`这两个类的实例。
```

**（2） ExecutorService有如下几个执行方法：**

```
- execute(Runnable)
- submit(Runnable)
- submit(Callable)
- invokeAny(...)
- invokeAll(...)
```

execute(Runnable)

   这个方法接收一个Runnable实例，并且异步的执行，

submit(Runnable)

`  submit(Runnable)`和`execute(Runnable)`区别是前者可以返回一个**Future**对象，通过返回的Future对象，我们可以检查提交的任务是否执行完毕，

**注：**如果任务执行完成，`future.get()`方法会返回一个null。注意，future.get()方法会产生阻塞。

submit(Callable)

`  submit(Callable)`和`submit(Runnable)`类似，也会返回一个Future对象，但是除此之外，submit(Callable)接收的是一个Callable的实现，Callable接口中的`call()`方法有一个返回值，可以返回任务的执行结果，而Runnable接口中的`run()`方法是`void`的，没有返回值。

**（3） ExecutorService关闭方法**

   当我们使用完成ExecutorService之后应该关闭它，否则它里面的线程会一直处于运行状态。举个例子，如果的应用程序是通过main()方法启动的，在这个main()退出之后，如果应用程序中的ExecutorService没有关闭，这个应用将一直运行。之所以会出现这种情况，是因为ExecutorService中运行的线程会阻止JVM关闭。

   要关闭ExecutorService中执行的线程，我们可以调用**`ExecutorService.shutdown()`**方法。在调用shutdown()方法之后，ExecutorService不会立即关闭，但是它不再接收新的任务，直到当前所有线程执行完成才会关闭，所有在shutdown()执行之前提交的任务都会被执行。

  如果想立即关闭ExecutorService，我们可以调用**`ExecutorService.shutdownNow()`**方法。这个动作将跳过所有正在执行的任务和被提交还没有执行的任务。但是它并不对正在执行的任务做任何保证，有可能它们都会停止，也有可能执行完成。





2. 自己new 线程池对象，

### 2.7 死锁

 产生死锁的四个必要条件如下。当下边的四个条件都满足时即产生死锁，即任意一个条件不满足既不会产生死锁。

 **（1）死锁的四个必要条件**

 

- 互斥条件：资源不能被共享，只能被同一个进程使用
- 请求与保持条件：已经得到资源的进程可以申请新的资源
- 非剥夺条件：已经分配的资源不能从相应的进程中被强制剥夺
- 循环等待条件：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程占用的资源

 

   举个常见的死锁例子：进程A中包含资源A,进程B中包含资源B，A的下一步需要资源B，B的下一步需要资源A，所以它们就互相等待对方占有的资源释放，所以也就产生了一个循环等待死锁。

 

 **（2）处理死锁的方法**

 

- 忽略该问题，也即鸵鸟算法。当发生了什么问题时，不管他，直接跳过，无视它；
- 检测死锁并恢复；
- 资源进行动态分配；
- 破除上面的四种死锁条件之一。





### 2.8 线程相关类

**（1）ThreadLocal**

 

   ThreadLocal它并不是一个线程，而是一个可以在每个线程中存储数据的数据存储类，通过它可以在指定的线程中存储数据，数据存储之后，只有在指定线程中可以获取到存储的数据，对于其他线程来说则无法获取到该线程的数据。 即多个线程通过同一个ThreadLocal获取到的东西是不一样的，就算有的时候出现的结果是一样的（偶然性，两个线程里分别存了两份相同的东西），但他们获取的本质是不同的。使用这个工具类可以简化多线程编程时的并发访问，很简洁的隔离多线程程序的竞争资源。

   对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响

get方法会返回一个当前线程的变量值，如果数组不存在就会创建一个新的。另外，对于“当前线程”和“数组”，数组对于每个线程来说都是不同的 values.table。而values是通过当前线程获取到的一个Values对象，因此这个数组是每个线程唯一的，不能共用，而下面的几句话也更直接了，获取一个索引，再返回通过这个索引找到数组中对应的值。这也就解释了为什么多个线程通过同一个ThreadLocal返回的是不同的东西。

**总结：**若多个线程之间需要共享资源，以达到线程间的通信时，就使用同步机制；若仅仅需要隔离多线程之间的关系资源，则可以使用ThreadLocal。

s
