# 学习面向对象内容的三条主线

1. java类及类的成员
2. 面向对象的三大特征
3. 其他关键字

<img src="https://bobbo.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20240815134736289.png" alt="image-20240815134736289" style="zoom: 200%;" />

# 1. java类及类的成员

## 1.1 简述

成员有 **成员变量(属性)，方法，构造器，代码块，内部类。**

## 1.2 java类

在1.2中 指的是外部类

**类的访问机制：**

在一个类中的访问机制：类中的方法可以直接访问类中的成员变量。 （例外：static方法访问非static，编译不通过。）

在不同类中的访问机制：先创建要访问类的对象，再用对象访问类中定义的成员



**类的可用修饰符**

public、缺省(default 包权限)

abstract、final





## 1.3 成员变量

对象属性的默认初始化赋值：当一个对象被创建时，会对其中各种类型的成员变量自动进行初始化赋值。

**成员变量的可用修饰符**

访问权限修饰符：public、protected、缺省default、private、

其他修饰符：static、final、volatile等

> 在这里要区分一下成员变量和局部变量![image-20240808145458596](https://bobbo.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20240808145458596.png)





## 1.4 方法

**方法的可用修饰符**

访问权限修饰符：public、protected、缺省default、private

非访问权限修饰符：abstract、static、final、synchronized、native

**方法的重载**

在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可

**方法的可变个数的形参**

例如

```java
public static void test(int a ,String…books);
//本质上books是一个数组
```



**方法参数的值传递机制**

分为基本数据类型 和引用数据类型 两种情况

 **基本数据类型的值传递**

对于基本数据类型，Java在调用方法时，会将参数的值复制一份传递给方法中的参数。这意味着方法内部对参数所做的任何修改，都不会影响到原始数据。这是因为方法操作的是参数值的一个副本。

```java
public class Test {  
    public static void main(String[] args) {  
        int num = 10;  
        changeValue(num);  
        System.out.println(num); // 输出 10，因为num的值没有被改变  
    }  
  
    public static void changeValue(int num) {  
        num = 20; // 这里改变的是num的副本，对原始变量无影响  
    }  
}
```

**引用数据类型的值传递**

对于引用数据类型（如对象、数组等），Java传递的是对象引用的值，而不是对象本身。这意味着方法接收的是对象在堆内存中的地址的副本。因此，如果在方法内部通过引用修改了对象的属性，那么这些修改会反映到原始对象上，因为两者都指向堆内存中的同一个对象。但是，如果方法内部尝试将引用变量指向一个新的对象，那么这个改变不会影响到原始引用变量，因为它仍然指向原来的对象。

```java
public void modifyObject(List<Integer> list) {
    list.add(10); // 修改了对象的状态
}

public static void main(String[] args) {
    List<Integer> myList = new ArrayList<>();
    myList.add(5);
    modifyObject(myList);
    System.out.println(myList); // 输出 [5, 10]，因为 list 的状态被修改了
}
```

```java
public void changeReference(List<Integer> list) {
    list = new ArrayList<>(); // 仅仅改变了局部引用，原始引用不受影响
    list.add(10);
}

public static void main(String[] args) {
    List<Integer> myList = new ArrayList<>();
    myList.add(5);
    changeReference(myList);
    System.out.println(myList); // 输出 [5]，因为原始引用没有改变
}
```





**递归方法**

方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。

## 1.5 构造器

**作用**：用于创建对象；给对象进行初始化（主要是初始化对象的成员变量）

**特征**：与类相同的名称，不声明返回值类型，没有修饰符修饰



根据参数不同，构造器可以分为如下两类： 

​	隐式无参构造器（系统默认提供） 

​	显式定义一个或多个构造器（无参、有参）





## 1.6 代码块

**作用**：对java类或对象进行初始化

**分类**: 一个类中代码块若有修饰符，则只能被static修饰，称为静态代码块 (static block)，没有使用static修饰的，为非静态代码块。

 static代码块通常用于初始化static的属性

![image-20240808163917851](https://bobbo.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20240808163917851.png)

> 成员变量（包括静态变量和非静态变量）赋值的执行顺序 
>
> ![image-20240808164033233](https://bobbo.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20240808164033233.png)

## 1.7 内部类

当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么整个内部的完整结构最好使用内部类。

**分类**：  成员内部类（static成员内部类和非static成员内部类） 

​			局部内部类（没有修饰符可用，地位跟局部变量差不多，在方法和代码块中）、匿名内部类

内部类的修饰符：public、private、protected、缺省default、abstract、final 、static  （通常使用private）

**成员内部类作为类的成员的角色**：

1. 和外部类不同，内部类的修饰符还可以声明为private或protected；
2. 可以调用外部类的结构 
3. Inner class 可以声明为static的，但此时就不能再使用外层类的非static的成员变量

**成员内部类作为类的角色：** 

1. 可以在内部定义属性、方法、构造器等结构 
2. 可以声明修饰为abstract类，因此可以被其它的内部类继承 
3. 可以声明修饰为final的  
4. 编译以后生成OuterClass$InnerClass.class字节码文件（也适用于局部内部类）

**局部内部类**

```java
class 外部类{
方法(){
 class 局部内部类{
 		}
	 }
 {
 class 局部内部类{
 		}
	 }
 }
```

 如何使用局部内部类 

1. 只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方 都不能使用该类 
2. 但是它的对象可以通过外部方法的返回值返回使用，返回值类型只能是局部内部类 的父类或父接口类

局部内部类和局部变量地位类似，不能使用public,protected,缺省,private

局部内部类不能使用static修饰，因此也不能包含静态成员



**匿名内部类**

匿名内部类不能定义任何静态成员、方法和类，只能创建匿名内部类的一 个实例。一个匿名内部类一定是在new的后面，**用其隐含实现一个接口或 继承一个类。**

{}之间的才叫匿名内部类，可以在匿名内部类中重写父类的方法或实现接口的方法

```java
new 父类构造器(参数列表) | 接口() {  
    // 匿名内部类的类体部分   这个括号之间的才叫匿名内部类
};
```

匿名内部类的特点  

1. 匿名内部类必须继承父类或实现接口
2. 匿名内部类只能有一个对象 
3. 匿名内部类对象只能使用多态形式引用

**示例1：实现接口**

假设有一个`Runnable`接口的简单实现，通常用于创建新线程。

注：lambda表达式只能化简只含有一个抽象方法的接口，不能化简继承类的方式

```java
new Thread(new Runnable() {  
    @Override  
    public void run() {  
        System.out.println("线程运行中...");  
    }  
}).start();
可以化简为
new Thread(
()->System.out.println("线程运行中...")
).start();
```

**示例2：继承类**

假设有一个`Person`类，我们想要创建一个`Person`的子类实例，但只需要这个子类一次。

```java
class Person {  
    void eat() {  
        System.out.println("人吃饭");  
    }  
}  
  
// 匿名内部类继承Person  
Person p = new Person() {  
    @Override  
    void eat() {  
        System.out.println("这个人吃面包");  
    }  
};  
  
p.eat(); // 输出：这个人吃面包
```





# 2. 面向对象的三大特征

## 2.1 封装

Java中通过将数据声明为私有的(private)，再提供公共的（public） 方法:getXxx()和setXxx()实现对该属性的操作，以实现下述目的： 

1. 隐藏一个类中不需要对外提供的实现细节； 
2. 使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑， 限制对属性的不合理操作；
3. 便于修改，增强代码的可维护性

![image-20240809170549739](https://bobbo.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20240809170549739.png)



## 2.2 继承

多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中， 那么多个类无需再定义这些属性和行为，只要继承那个类即可。 

此处的多个类称为子类(派生类)，单独的这个类称为父类(基类 或超类)。可以理解为:“子类is a 父类” 子类不是父类的子集， 而是对父类的“扩展”。

类继承语法规则: class Subclass extends SuperClass{ }

作用： 

​	继承的出现减少了代码冗余，提高了代码的复用性。 

​	继承的出现，更有利于功能的扩展。 

​	继承的出现让类与类之间产生了关系，**提供了多态的前提**。

### 方法的重写

在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。



### 子类对象的实例化过程

这里其实用到了关键字super



## 2.3 多态

有继承才有多态

对象的多态性：父类的引用指向子类的对象 

可以直接应用在抽象类和接口上



Java引用变量有两个类型：**编译时类型和运行时类型。**

​	编译时类型由声明 该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。简称：编译时，看左边；运行时，看右边。

> ### **编译时类型 (Compile-Time Type)**
>
> - 编译时类型是编译器在编译代码时所知道的变量类型。
> - 它由变量声明时指定的类型决定，也就是左边的类型。例如
>
> ```java
> Animal myAnimal = new Dog();
> ```
>
> 在这段代码中，`myAnimal`的编译时类型是`Animal`。因为`myAnimal`是用`Animal`类型声明的。
>
> ### **运行时类型 (Runtime Type)**
>
> - 运行时类型是程序在运行时对象的实际类型。
>
> - 它由变量指向的对象的真实类型决定，也就是`new`操作符创建的对象的类型。例如：
>
> - ```java
>   Animal myAnimal = new Dog();
>   ```
>
>   在这段代码中，`myAnimal`的运行时类型是`Dog`，因为`myAnimal`引用的是一个`Dog`对象。



若编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphism) 

多态情况下，“看左边”：看的是父类的引用（父类中不具备子类特有的方法） 

​					“看右边”：看的是子类的对象（实际运行的是子类重写父类的方法）



**成员方法：** 

​	编译时：要查看引用变量所**声明的类**中是否有所调用的方法。（也就是说父类要有这个方法） 

​	运行时：调用实际**new**的对象所属的类中的重写方法。 

**成员变量：** 不具备多态性，只看引用变量所声明的类。（看左边）



**instanceof 操作符**

​		x instanceof A：检验x是否为类A的对象，返回值为boolean型。

​		 要求x所属的类与类A必须是子类和父类的关系，否则编译错误。 

​		如果x属于类A的子类B，x instanceof A值也为true



## 对象类型转换

对象类型转换本身不属于多态性，但它与多态密切相关。向上转型是多态的实现手段之一，而向下转型则通常用于恢复对具体子类功能的访问。因此，在多态的上下文中，类型转换常常与多态性一起使用，但它们并非同一个概念。

**基本类型的转换**

自动类型转换：小的数据类型可以自动转换成大的数据类型 如long g=20; double d=12.0f 

强制类型转换：可以把大的数据类型强制转换(casting)成小的数据类型 如float f=(float)12.0; int a=(int)1200

**引用类型的转换（利用多态性）**

向上转型: 将子类对象转换为父类类型的引用。这种转换是自动的，不需要显式的类型转换。向上转型是多态性的基础，因为它允许父类引用指向子类对象。

```java
Animal myAnimal = new Dog();  // 向上转型，自动进行
myAnimal.makeSound();         // 调用的是 Dog 的 makeSound 方法
```



向下转型：将父类类型的引用转换为子类类型的引用。由于向下转型可能会导致`ClassCastException`，所以需要显式进行类型转换。经常用于多态性场景中，当你需要访问子类特有的方法或属性时，就需要进行向下转型。

```java
Animal myAnimal = new Dog();  // 向上转型
Dog myDog = (Dog) myAnimal;   // 向下转型，显式进行
myDog.bark();                 // 调用 Dog 特有的方法
```





# 3. 其他关键字

## this

- 它在方法内部使用，即这个方法所属对象的引用； 

它在构造器内部使用，表示该构造器正在初始化的对象。

- this 可以调用类的属性、方法和构造器

- 当在方法内需要用到调用该方法的对象时，就用this

 具体的：我们可以用this来区分属性和局部变量。 比如：this.name = name;

> 1. 在任意方法或构造器内，如果使用当前类的成员变量或成员方法可以在其前面添加this， 增强程序的阅读性。不过，通常我们都习惯省略this。
>
> 2. 当形参与成员变量同名时， 如果在方法内或构造器内需要 使用成员变量，必须添加this来 表明该变量是类的成员变量 
> 3. 使用this访问属性和方法时， 如果在本类中未找到，会从父 类中查找
> 4. 4.this可以作为一个类中 构造器相互调用的特殊格式(比如说有参构造器 调用无参构造器)



## super

super可用于访问父类中定义的属性 

super可用于调用父类中定义的成员方法 

super可用于在子类构造器中调用父类的构造器

> 子类中所有的构造器默认都会访问父类中空参数的构造器 (Java会自动插入一个对父类无参数构造器的调用。)
>
> 当父类中没有空参数的构造器时，子类的构造器必须通过this(参数列表)(间接调用另一个构造器，最终都会有一个构造器负责调用父类构造器)
>
> 或者super(参数列表)语句指定调用本类或者父类中相应的构造器。同时，只能”二选一”，且必须放在构造器的首行

尤其当子父类出现同名成员时，可以用super表明调用的是父类中的成员 

super的追溯不仅限于直接父类 

super和this的用法相像，this代表本类对象的引用，super代表父类的内存 空间的标识



## static

如果想让一个类的所有实例共享数据，就用类变量！ 在内存里有自己的地址 ，不跟随某个对象。静态变量，静态方法存储在方法区

> 类属性作为该类各个对象之间共享的变量。在设计类时,分析哪 些属性不因对象的不同而改变，将这些属性设置为类属性。相应 的方法设置为类方法。
>
> 如果方法与调用者无关，则这样的方法通常被声明为类方法，由 于不需要创建对象就可以调用类方法，从而简化了方法的调用。

**适用范围**：在Java类中，可用static修饰属性、方法、代码块、内部类

被修饰后的成员具备以下特点： 

​	随着类的加载而加载 

​	优先于对象存在 

​	修饰的成员，被所有对象所共享 

​	访问权限允许时，可不创建对象，直接被类调用



没有对象的实例时，可以用类名.方法名()的形式访问由static修饰的类方法。 

在static方法内部只能访问类的static修饰的属性或方法，不能访问类的非static的结构



## final

在Java中声明类、变量和方法时，可使用关键字final来修饰,表示“最终的”。

final标记的类不能被继承。提高安全性，提高程序的可读性。 如String类、System类、StringBuffer类 

final标记的方法不能被子类重写。 比如：Object类中的getClass()。 

final标记的变量(成员变量或局部变量)即称为常量。名称大写，且只能被赋值一次。



# 抽象类和接口

## 抽象类

用abstract关键字来修饰一个类，这个类叫做抽象类。 

用abstract来修饰一个方法，该方法叫做抽象方法。 

抽象方法：只有方法的声明，没有方法的实现。以分号结束：

含有抽象方法的类必须被声明为抽象类。 

抽象类不能被实例化。抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体。若没有重写全部的抽象方法，仍为抽象类。 

不能用abstract修饰变量、代码块、构造器； 只能修饰类和方法

不能用abstract修饰私有方法、静态方法、final的方法、final的类。



## 接口

接口(interface)是抽象方法和常量值定义的集合

接口的特点： 

​	用interface来定义。 

​	接口中的所有成员变量都默认是由public static final修饰的。 

​	接口中的所有抽象方法都默认是由public abstract修饰的。 

​	接口中没有构造器。 

​	接口采用多继承机制

实现接口的类中必须提供接口中所有方法的具体实现内容，方可实例化。否则，仍为抽象类。 

接口的主要用途就是被实现类实现。（面向接口编程） 

与继承关系类似，接口与实现类之间存在多态性

# object类

Object类是所有Java类的根父类 

如果在类的声明中未使用extends关键字指明其父类，则默认父类 为java.lang.Object类

![image-20240815141010686](https://bobbo.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20240815141010686.png)

![image-20240815141050944](https://bobbo.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20240815141050944.png)

![image-20240815141226347](https://bobbo.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20240815141226347.png)



# 包装类

Java的包装类（Wrapper Classes）是Java提供的一种特殊的类，它们将基本数据类型（如`int`、`double`、`boolean`等）封装成对象。每个包装类都只有一个成员变量，即它们所对应的基本数据类型的值。

1. **构造器**：允许你使用基本数据类型的值来创建包装类的实例。
2. **`toString()`**：返回该对象的字符串表示形式，通常是它所包装的基本数据类型的字符串表示。
3. **`equals(Object obj)`**：比较此对象与指定对象是否相等。对于包装类来说，这通常意味着比较它们所包装的值是否相等。
4. **`hashCode()`**：返回该对象的哈希码值。这对于将包装类对象用作哈希表的键非常重要。
5. **静态方法**：一些包装类提供了静态方法，如`Integer.parseInt(String s)`用于将字符串转换为整数，`Double.valueOf(String s)`用于将字符串转换为`Double`对象等。
6. **`compareTo(T o)`**（对于实现了`Comparable`接口的包装类，如`Integer`、`Double`等）：将此对象与指定对象进行比较。
7. **类型转换方法**：虽然不直接作为成员方法，但包装类允许通过自动装箱和拆箱进行基本数据类型与包装类之间的转换。